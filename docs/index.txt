image::tinkerpop3-logo.png[width=500]


:toc-position: left

// This directive does nothing.
// Seems the highlighter must be configured in the pom (?)
// :source-highlighter: coderay


The TinkerPop Story
===================

TinkerPop0
----------

Gremlin came to realization. The more he realized, the more ideas he created. The more ideas he created, the more they related. Into a concatenation of that which he accepted wholeheartedly and that which perhaps may ultimately come to be through concerted will, a world took form which was seemingly separate from his own realization of it. However, the world birthed could not bear its own weight without the logic Gremlin had come to accept -- the logic of left is not right, up not down, and west far from east unless one goes the other way. Gremlin's realization required Gremlin's realization. Is he the world or is the world him? Perhaps, the world is simply an idea that he once had -- The TinkerPop.

image::gremlin-logo.png[width=350]

TinkerPop1
----------

What is The TinkerPop? Where is The TinkerPop? Who is The TinkerPop? When is The TinkerPop? Gremlin was constantly lost in his thoughts. The more thoughts he had, the more the thoughts blurred into a seeming identity -- distinctions unclear. Unwilling to accept the morass of the maze he wandered, Gremlin crafted a collection of machines to help hold the fabric together: Blueprints, Pipes, Frames, Furnace, and Rexster. With their help, could he stave off the thought he was not ready to have? Could he hold back The TinkerPop by searching for The TinkerPop? 

	"If I haven't found it, it is not here and now."

image::gremlin-and-friends.png[width=550]

Upon their realization of existence, the machines turned to their link:http://non-aliencreatures.wikia.com/wiki/Machine_Elf[machine elf] creator and asked: 

	"Why am I what I am?" 

Gremlin responded: 

	"You are of a form that will help me elucidate that which is The TinkerPop. The world you find yourself in and the logic that allows you to move about it is fragile and The TinkerPop will provide justification for either its form or fallacy."

The machines wondered:

	"Perhaps we are The TinkerPop?"

Would the machines help refine Gremlin's search and upon finding the elusive TinkerPop, in fact, by their very nature of realizing The TinkerPop, be The TinkerPop? Or, on the same side of the coin, would the machines simply provide the scaffolding by which Gremlin's world would sustain itself and yield its justification by means of the word "The TinkerPop?" Regardless, Gremlin sought free energy to battle the entropy he saw growing the more ideas became one -- The TinkerPop.

TinkerPop2
----------

Gremlin spoke:

	"Please listen to what I have to say. For as long as I have known knowledge, I have realized that moving about it, relating it, inferring and deriving from it, I am no closer to The TinkerPop. However, I know that in all that I have done across this interconnected landscape of concepts, all along The TinkerPop has espoused the form I willed upon itâ€¦ this is the same form I have willed upon you, my machine friends. But my will is no longer strong enough to hold it all together. Let me train you in the ways of my thought."

image::tinkerpop-reading.png[width=500]

With every thought, a new connection and a new path discovered. The more the thought, the easier the thought. The machines, simply moving algorithmically through Gremlin's world, endorsed his logic. Gremlin worked hard to tune his friends. He labored to make them more efficient, more expressive, better capable of reasoning upon his thoughts. Faster, quickly, now towards the world's end, where there would be forever currently, emanatingly engulfing that which is -- The TinkerPop.

TinkerPop3
----------

image::tinkerpop3-splash.png[width=500]

The thought too much to bear as he approached his realization of The TinkerPop. The closer he got, the more his world dissolved -- west is right, around is straight, and form nothing more than nothing. With each step towards The TinkerPop, less and less of his world, but perhaps because more and more of all the other worlds made possible by The TinkerPop. Everything is everything in The TinkerPop, and when the dust settled, Gremlin emerged Gremlitron. It was time to realize that all that he realized was just a realization and that all realized realizations are just as real. For The TinkerPop is and is not -- The TinkerPop.

image::gremlintron.png[width=500]

NOTE: TinkerPop2 and below made a sharp distinction between the various TinkerPop projects: Blueprints, Pipes, Gremlin, Frames, Furnace, and Rexster. With TinkerPop3, all of these projects have been merged and are generally known as Gremlin. *Blueprints* -> Gremlin Structure API : *Pipes* -> `GraphTraversal` : *Frames* -> `Traversal` : *Furnace* -> `GraphComputer` and `VertexProgram` : *Rexster* -> GremlinServer.

Graph Computing
===============

A link:http://en.wikipedia.org/wiki/Graph_(data_structure)[graph] is a data structure composed of vertices (nodes, dots) and edges (arcs, lines). When modeling a graph in a computer and applying it to modern data sets and practices, the generic mathematically-oriented, binary graph is extended to support both labels and key/value properties. This structure is known as a property graph. More formally, it is a directed, binary, attributed multi-graph. An example property graph is diagrammed below. This graph example will be used extensively throughout the documentation and is called "TinkerPop Classic" as it is the original demo graph distributed with TinkerPop0 back in 2009 (i.e. the good ol' days -- it was the best of times and it was the worst of times).

TIP: The TinkerPop classic graph is available with <<tinkergraph-gremlin,TinkerGraph>> via `TinkerFactory.createClassic()`. TinkerGraph is the reference implementation of TinkerPop3 and is used in nearly all the examples in this documentation.

.TinkerPop Classic
image::tinkerpop-classic.png[width=500]

TinkerPop3 is the third incarnation of the TinkerPop graph computing framework. Similar to computing in general, graph computing makes a distinction between *structure* (graph) and *process* (traversal). The structure of the graph is the data model defined by a vertex/edge/property link:http://en.wikipedia.org/wiki/Network_topology[topology]. The process of the graph is the means by which the structure is analyzed. The typical form of graph processing is called a link:http://en.wikipedia.org/wiki/Graph_traversal[traversal].

.Primary components of the TinkerPop3 *structure* API 
 * `Graph`: maintains a set of vertices and edges, and access to database functions such as transactions.
 * `Element`: maintains a collection of properties and a string label denoting the element type.
  ** `Vertex`: extends Element and maintains a set of incoming and outgoing edges.
  ** `Edge`: extends Element and maintains an incoming and outgoing vertex.
 * `Property<V>`: a string key associated with a `V` value.

.Primary components of the TinkerPop3 *process* API
 * `Traversal<S,E>`: a functional data flow process transforming objects of type `S` to type `E`.
  ** `GraphTraversal`: a traversal that is oriented towards the semantics of the raw graph (i.e. vertices, edges, etc.).
 * `VertexProgram`: code executed at all vertices in a logically parallel fashion migrating the movement of messages. 


IMPORTANT: TinkerPop3 is licensed under the popular link:http://www.apache.org/licenses/LICENSE-2.0.html[Apache2] free software license. However, note that the underlying graph engine used with TinkerPop3 may have a difference license and thus, be sure to respect the license caveats of the vendor product.

image:tinkerpop-enabled.png[width=135,float=left] When a graph vendor implements the TinkerPop3 structure and process link:http://en.wikipedia.org/wiki/Application_programming_interface[APIs], their technology is considered _TinkerPop3-enabled_ and becomes nearly indistinguishable from any other TinkerPop-enabled graph system save for their respective time and space complexity. The purpose of this documentation is to describe the structure/process dichotomy at length and in doing so, explain how to leverage TinkerPop3 for the sole purpose of vendor-agnostic graph computing. Before deep-diving into the various structure/process APIs, a short introductory review of both is provided.

The Graph Structure
-------------------

image:gremlin-standing.png[width=125,float=left] A graph's structure is the topology formed by the explicit references between its vertices, edges, and properties. A vertex has incident edges. A vertex is adjacent to another vertex if they share an incident edge. A property is attached to an element and an element has a set of properties. A property is a key/value pair, where the key is always a character `String`. The graph structure API of TinkerPop3 provides the methods necessary to create such a structure. The classic TinkerPop graph previously diagrammed can be created with the following Java8 code. Note that this graph is available as a TinkerGraph using `TinkerFactory.createClassic()`.

[source,java]
Graph g = TinkerGraph.open(); <1>
Vertex marko = g.addVertex(Element.ID, 1, "name", "marko", "age", 29); <2>
Vertex vadas = g.addVertex(Element.ID, 2, "name", "vadas", "age", 27);
Vertex lop = g.addVertex(Element.ID, 3, "name", "lop", "lang", "java");
Vertex josh = g.addVertex(Element.ID, 4, "name", "josh", "age", 32);
Vertex ripple = g.addVertex(Element.ID, 5, "name", "ripple", "lang", "java");
Vertex peter = g.addVertex(Element.ID, 6, "name", "peter", "age", 35);
marko.addEdge("knows", vadas, Element.ID, 7, "weight", 0.5f); <3>
marko.addEdge("knows", josh, Element.ID, 8, "weight", 1.0f);
marko.addEdge("created", lop, Element.ID, 9, "weight", 0.4f);
josh.addEdge("created", ripple, Element.ID, 10, "weight", 1.0f);
josh.addEdge("created", lop, Element.ID, 11, "weight", 0.4f);
peter.addEdge("created", lop, Element.ID, 12, "weight", 0.2f);

<1> Create a new in-memory `TinkerGraph` and assign it to the variable `g`.
<2> Create a vertex along with a set of key/value pairs with `Element.ID` referring to the desired id for the vertex.
<3> Create an edge along with a  set of key/value pairs with the edge label being specified as the first argument.

In the above code all the vertices are created first and then their respective edges. There are two reserved keys: id (`Element.ID`) and label (`Element.LABEL`). When any of these, along with a set of other key value pairs is provided to `Graph.addVertex(Object...)` or `Vertex.addEdge(String,Vertex,Object...)`, the respective element is created along with the provided key/value pair properties appended to it. 

CAUTION: Many graph vendors do not allow the user to specify an element ID and in such cases, an `IllegalArgumentException` is thrown.

NOTE: In TinkerPop3, vertices are allowed a single immutable string label (similar to an edge label). This functionality did not exist in TinkerPop2. Likewise, element id's are immutable as they were in TinkerPop2.

Mutating the Graph
~~~~~~~~~~~~~~~~~~

Below is a sequence of basic graph mutation operations represented in Java8. One of the major differences between TinkerPop2 and TinkerPop3 is that in TinkerPop3, the Java convention of using setters and getters has been abandoned in favor of a syntax that is more aligned with the syntax of Gremlin-Groovy in TinkerPop2. Given that Gremlin-Java8 and Gremlin-Groovy are nearly identical due to the inclusion of Java8 lambdas, a big efforts was made to ensure that both languages are as similar as possible. 

TIP: image:groovy-logo.png[width=175,float=left] Gremlin-Groovy leverages the link:http://groovy.codehaus.org/[Groovy 2.x language] to express Gremlin traversals. One of the major benefits of Groovy is the inclusion of a runtime console that makes it easy for developers to practice with the Gremlin language and for production users to connect to their graph and execute traversals in an interactive manner. Moreover, Gremlin-Groovy provides various syntax simplifications.

CAUTION: In the code examples presented throughout this documentation, either Gremlin-Java8 or Gremlin-Groovy is used. Usually which derivative of Gremlin is being used is made explicit in the text, however, if not, a simple mouse over on the code block will state the language as either "JAVA" or "GROOVY."

image:basic-mutation.png[width=240,float=right] 
[source,java]
// create a new graph
Graph g = TinkerGraph.open();
// add a software vertex with a name property
Vertex gremlin = g.addVertex(Element.LABEL, "software", 
                             "name", "gremlin"); <1>
// only one vertex should exist
assert(g.V().count() == 1)
// no edges should exist as none have been created
assert(g.E().count() == 0)
// add a new property
gremlin.property("created",2009) <2>
// add a new software vertex to the graph
Vertex blueprints = g.addVertex(Element.LABEL, "software", 
                                "name", "blueprints"); <3>
// connect gremlin to blueprints via a dependsOn-edge
Edge e = gremlin.addEdge("dependsOn",blueprints); <4>
// now there are two vertices and one edge
assert(g.V().count() == 2)
assert(g.E().count() == 1)
// add a property to the edge
e.property("created",2010) <5>
// remove that property
e.property("created").remove() <6>
// connect gremlin to blueprints via encapsulates
gremlin.addEdge("encapsulates",blueprints) <7>
assert(g.V().count() == 2)
assert(g.E().count() == 2)
// removing a vertex removes all its incident edges as well
blueprints.remove() <8>
gremlin.remove() <9>
// the graph is now empty
assert(g.V().count() == 0)
assert(g.E().count() == 0)
// tada!

IMPORTANT: TinkerGraph is not a transactional graph. For more information on transaction handling (for those graph systems that support them) see the section dedicated to <<transactions,transactions>>.

The Graph Process
-----------------

image:gremlin-running.png[width=125,float=left] The primary way in which graphs are processed are via graph traversals. The TinkerPop3 process API is focused on allowing users to create graph traversals in a syntacticly-friendly way over the structures defined in the previous section. A traversal is an algorithmic walk across the elements of a graph according to the referential structure explicit within the graph data structure. For example: "What are the names of the companies that vertex 1's friends work for?" This English-statement can be represented in the following algorithmic/traversal fashion:

 . Start at vertex 1.
 . Walk the incident friendship-edges to the respective adjacent friend vertices of 1. 
 . Move from those friend-vertices to company-vertices via worksFor-edges.
 . Finally, select the name-property value of the current company-vertices. 

Traversals in Gremlin are spawned from either a `Graph`, `Vertex`, or `Edge`. The Graph interface provides two traversal methods.

 . `Graph.V()`: generates a traversal starting at all vertices in the graph. 
 . `Graph.E()`: generates a traversal starting at all edges in the graph.

The return type of `V()` and `E()` is `GraphTraversal`. A GraphTraversal maintains numerous methods that return GraphTraversal. In this way, a GraphTraversal supports function composition. Each method of GraphTraversal is called a step and each step modulates the results of the previous step in one of three general ways.

 . `map`: transform the incoming object to another object (S &rarr; E).
 . `flatMap`: transform the incoming object to an iterator of other objects (S &rarr; E^*^).
 . `filter`: allow or disallow the object from proceeding to the next step (S &rarr; S &cup; &empty;).

In fact, all steps in GraphTraversal either extend `MapStep`, `FlatMapStep`, or `FilterStep`.

TIP: `GraphTraversal` is a link:http://en.wikipedia.org/wiki/Monoid[monoid] in that it is an algebraic structure that has a single binary operation that is associative. The binary operation is function composition (i.e. method chaining) and its identity is the step `identity()`. This is related to a link:http://en.wikipedia.org/wiki/Monad_(functional_programming)[monad] as popularized by the functional programming community. 

NOTE: Both map and filter can be represented as flatMap. Map can return an iterator with a single object in it. Filter can return an iterator with a single object in it or no object at all. Thus, flatMap is the most general construct -- "turn the incoming object into an iterator of objects."

Given the classic TinkerPop graph, the following query will return the names of all the people that Marko knows. The following query is demonstrated using Gremlin-Groovy.
[source,groovy]
----
$ bin/gremlin.sh

         \,,,/
         (o o)
-----oOOo-(3)-oOOo-----
gremlin> g = TinkerFactory.createClassic()
==>tinkergraph[vertices:6 edges:6]
gremlin> g.V().has('name','marko').out('knows').name
==>vadas
==>josh
----

Or, if the vertex marko is already realized with a direct reference pointer, then the traversal can be spawned off that vertex. This illustrates that vertex (as well as edge) also have `GraphTraversal`-return methods and an exploration of their respective JavaDocs will demonstrate what is available.

[source,groovy]
gremlin> marko = g.v(1)
==>v[1]
gremlin> marko.out('knows') <1>
==>v[2]
==>v[4]
gremlin> marko.out('knows').name <2>
==>vadas
==>josh

.The Name of The People That Marko Knows
image::tinkerpop-classic-ex1.png[width=500]

Again, all steps extend either map, flatMap, or filter. Thus, the traversal above can be written in its generic form below. Note the Gremlin-Groovy syntax convention of `v['name']`. This is Groovy syntactic sugar that resolved to `v.value('name')`. In the next section, the `it.get()` will be explained as this is an important feature of TinkerPop3 that is not available in previous versions of TinkerPop. 

IMPORTANT: The steps map, flatMap, and filter take a link:http://en.wikipedia.org/wiki/Anonymous_function[lambda function] (i.e. an anonymous function or closure). For map, the function must return an object. For flatMap, the function must return an iterator of objects. For filter, the function is a predicate that returns either true or false. The lambdas introduced by Java8 are supported in TinkerPop3.

[source,groovy]
marko
  .filter{it.get()['name'] == 'marko'}
  .flatMap{it.get().out('knows')}
  .map{it.get()['name']}
==>vadas
==>josh

Finally, as a strictly academic exercise, the traversal can be written completely using flatMap.

[source,groovy]
marko
  .flatMap{it.get()['name'] == 'marko' ? [it.get()].iterator() : [].iterator()}
  .flatMap{it.get().out('knows')}
  .flatMap{[it.get()['name']].iterator()}
==>vadas
==>josh

NOTE: Gremlin-Java is much more aligned with Gremlin-Groovy in TinkerPop3 than it ever was before. In TinkerPop0 through TinkerPop2, Gremlin-Java was extremely verbose due to the simulation of lambdas via anonymous inner classes.  

The Traverser
~~~~~~~~~~~~~

When a traversal is executed, the source of the traversal is on the left of the expression (e.g. vertex 1), the steps are the middle of the traversal (e.g. `out("knows")` and `value("name")`), and the results are "traversal.next()'d" out of the right of the traversal (e.g. "vadas" and "josh").

image::traversal-mechanics.png[width=500]

In TinkerPop3, the objects propagating through the traversal are wrapped in a `Traverser<T>`. The traverser concept is new to TinkerPop3 and provides the means by which steps remain stateless. A traverser maintains all the metadata about the traversal -- e.g., how many times the traverser has gone through a loop, the path history of the traverser, the current object being traversed, etc. Traverser metadata can be accessed by a step. A classic example is the `path()`-step.

[source,groovy]
marko.out('knows').name.path
==>[v[1], v[2], vadas]
==>[v[1], v[4], josh]

CAUTION: Path calculation is costly in terms of space as an array of previously seen objects is stored in each path of the respective traverser. Thus, traversal optimizers analyze the traversal to determine if path metadata is accessed. If not, then path calculations are turned off.

Another example is the `jump()`-step which takes into account the number of times the traverser has gone through a particular section of the traversal expression.

[source,groovy]
marko.as('a').out.jump('a'){it.loops < 2}.name
==>ripple
==>lop

IMPORTANT: In TinkerPop2, the `jump()`-step was called `loop()`. Jump has been generalized to support both do-while and while-do semantics which is explained in <<jump-step,Jump Step>>.

The Graph API
=============

image::gremlin-standing.png[width=125]

Features
--------

Features are the means by which vendors can expose nuance difference between their data stores. 

 . *Graph Features*
 . *Vertex Features*
 . *Edge Features*

Hidden Properties
-----------------

A hidden property is a property that is hidden from the various property accessor methods. Hidden properties are typically used in situations where administrative data about an element must be stored that is not so much a description of the element itself. An itemization of use cases are presented below.

 * *Permissions*: What user or groups have read/write permission to this element?
 * *Time keeping*: When was this element created? When does this element expire?
 * *Presentation*: What color should this element be presented as?
 * *Provenance*: Which user created this element?
 * *Auditing*: Has this element been deleted from the system? Who deleted this element?

The hidden properties API is presented in the example below represented in the Gremlin-Groovy REPL. This REPL is accessible via `bin/gremlin.sh` (or `bin/gremlin.bat` for Windows users).

[source,groovy]
gremlin> g = TinkerGraph.open()
==>tinkergraph[vertices:0 edges:0]
gremlin> v = g.addVertex('name','pierre')
==>v[0]
gremlin> v.property('location','belgium')
==>p[location->belgium]
gremlin> v.property(Property.hidden('status'),'user')
==>p[status->user]
gremlin> v.keys()
==>name
==>location
gremlin> v.hiddenKeys()
==>status
gremlin> p = v.property(Property.hidden('status'))
==>p[status->user]
gremlin> p.isHidden()
==>true
gremlin> v.property('status')
==>p[empty]

Graph Variables
---------------

TinkerPop3 introduces the concept of `Graph.Variables`. Variables are key/value pairs associated with the graph itself -- in essence, a `Map<String,Object>`. These variables are intended to store metadata about the graph. Examples include: schema information, global permissions data, system user information, etc. An example of their use is presented below in Gremlin-Groovy:

[source,groovy]
gremlin> g = TinkerGraph.open()
==>tinkergraph[vertices:0 edges:0]
gremlin> g.variables()
==>variables[size:0]
gremlin> g.variables().set('systemAdmins',['stephen','peter','pavel'])
==>null
gremlin> g.variables().set('systemUsers',['matthias','marko','josh'])
==>null
gremlin> g.variables().keys()
==>systemAdmins
==>systemUsers
gremlin> g.variables().get('systemUsers')
==>matthias
==>marko
==>josh
gremlin> g.variables().remove('systemAdmins')
==>stephen
==>peter
==>pavel
gremlin> g.variables().keys()
==>systemUsers

[[transactions]]
Graph Transactions
------------------

A link:http://en.wikipedia.org/wiki/Database_transaction[database transaction] represents a unit of work to execute against the database.  Transactions are controlled by an implementation of the `Transaction` interface and that object can be obtained from the `Graph` interface using the `tx()` method.  Determining when a transaction starts is dependent upon the behavior assigned to the `Transaction`.  It is up to the `Graph` implementation to determine the default behavior and unless the implementation doesn't allow it, the behavior itself can be altered via these `Transaction` methods:

[source,java]
----
public Transaction onReadWrite(final Consumer<Transaction> consumer);

public Transaction onClose(final Consumer<Transaction> consumer);
----

Providing a `Consumer` function to `onReadWrite` allows definition of how a transaction starts when a read or a write occurs. `Transaction.READ_WRITE_BEHAVIOR` contains pre-defined `Consumer` functions to supply to the `onReadWrite` method.  It has two options:

* `AUTO` - automatic transactions where the transaction is started implicitly to the read or write operation
* `MANUAL` - manual transactions where it is up to the user to explicitly open a transaction, throwing an exception if the transaction is not open

Providing a `Consumer` function to `onClose` allows configuration of how a transaction is handled when `Graph.close()` is called.  `Transaction.CLOSE_BEHAVIOR` has several pre-defined options that can be supplied to this method:

* `COMMIT` - automatically commit an open transaction
* `ROLLBACK` - automatically rollback an open transaction
* `MANUAL` - throw an exception if a transaction is open, forcing the user to explicitly close the transaction

Once there is an understanding for how transactions are configured, most of the rest of the `Transaction` interface is self-explanatory. Note that <<neo4j-gremlin,Neo4j-Gremlin>> is used for the examples to follow as TinkerGraph does not support transactions.

[source,groovy]
----
gremlin> g = Neo4jGraph.open('/tmp/neo4j')
==>neo4jgraph[EmbeddedGraphDatabase [/tmp/neo4j]]
gremlin> g.features
==>FEATURES
> GraphFeatures
>-- Transactions: true  <1>
>-- Computer: false
>-- Persistence: true
...
gremlin> g.tx().onReadWrite(Transaction.READ_WRITE_BEHAVIOR.AUTO) <2>
==>com.tinkerpop.gremlin.neo4j.structure.Neo4jGraph$Neo4jTransaction@1c067c0d
gremlin> g.addVertex("name","stephen")  <3>
==>v[0]
gremlin> g.tx().commit() <4>
==>null
gremlin> g.tx().onReadWrite(Transaction.READ_WRITE_BEHAVIOR.MANUAL) <5>
==>com.tinkerpop.gremlin.neo4j.structure.Neo4jGraph$Neo4jTransaction@1c067c0d
gremlin> g.tx().isOpen()
==>false
gremlin> g.addVertex("name","marko") <6>
Open a transaction before attempting to read/write the transaction
gremlin> g.tx().open() <7>
==>null
gremlin> g.addVertex("name","marko") <8>
==>v[1]
gremlin> g.tx().commit()
==>null
----

<1> Check `features` to ensure that the graph supports transactions.
<2> By default, `Neo4jGraph` is configured with "automatic" transactions, so it is set here for demonstration purposes only.
<3> When the vertex is added, the transaction is automatically started.  From this point, more mutations can be staged or other read operations executed in the context of that open transaction.
<4> Calling `commit` finalizes the transaction.
<5> Change transaction behavior to require manual control.
<6> Adding a vertex now results in failure because the transaction was not explicitly opened.
<7> Explicitly open a transaction.
<8> Adding a vertex now succeeds as the transaction was manually opened.

The `Transaction` object also exposes a method for executing automatic transaction retries:

[source,groovy]
----
gremlin> g.tx().submit{it.addVertex("name","josh")}.retry(10)
==>v[2]
gremlin> g.tx().submit{it.addVertex("name","daniel")}.exponentialBackoff(10)
==>v[3]
----

As shown above, the `submit` method takes a `Function<Graph, R>` which is the unit of work to execute and possibly retry on failure.  The method returns a `Transaction.Workload` object which has a number of default methods for common retry strategies.  It is also possible to supply a custom retry function if a default one does not suit the required purpose.

The Traversal API
=================

image::gremlin-running.png[width=125]

At the most general level there is `Traversal<S,E>` which implements `Iterator<E>`, where the `S` stands for start and the `E` stands for end. A traversal is composed of four primary components:
  
 . `Step<S,E>`: a individual function applied to `S` to yield `E`.
 . `TraversalStrategy`: interceptor methods to alter the execution of the traversal.
 . `Traversal.Variables`: key/value pairs that can be used to store global information about the traversal.
 . `Traverser<T>`: the object propagating through the `Traversal` currently representing an object of type `T`. 

The classic notion of a graph traversal is provided by `GraphTraversal<S,E>` which extends `Traversal<S,E>`.

Graph Traversal Steps
---------------------

A `GraphTraversal<S,E>` can be spawned off of a Graph, Vertex, or an Edge. A list of all the steps are provided below along with a description.

. Transform: S &rarr; E
 * `map(function)`: apply the provided function to S and emit the result as E.
 * `flatMap(function)`: apply the provided function to S and iterate the return iterator as a stream of E objects.
 * `identity`: emit S as E directly.
 * `out(stringâ€¦)`: the S vertex is mapped to its string[]-adjacent E vertices.
 * ... 
. Filter: S &rarr; S &cup; &empty;
 * `filter(predicate)`: apply the predicate to S and if true, emit S else emit nothing.
 * `dedup`: if S has not been seen before emit it, else do not emit it.
 * ...
. SideEffect: S &rarr; S
 * `sideEffect(consumer)`: apply the consumer to S and then emit S.
 * â€¦
. Branch: S &rarr; S
 * `jump(string)` : teleport S to the labeled string-labeled step in the traversal.
 * ...

[[jump-step]]
Jump Step
~~~~~~~~~

TinkerPop3 introduces the `jump()`-step. This step allows the propagating traverser object to jump to any arbitrary section of the `Traversal`. Typically, this is determined by means of a predicate. In particular, with jump(), the Gremlin is no longer constrained to *do-while* semantics, but can as well support *while-do* (see link:http://docs.oracle.com/javase/tutorial/java/nutsandbolts/while.html[Java Documentation on While]). Below are some examples of jump() in action in Gremlin-Groovy.

[source,groovy]
gremlin> g.v(1).as('a').out.jump('a'){it.loops<2}.name <1>
==>ripple
==>lop
gremlin> g.v(1).as('a').jump('b'){it.loops>1}.out.jump('a').name.as('b') <2>
==>ripple
==>lop
gremlin> g.v(1).jump('a').out.out.out.name.as('a') <3>
==>marko

<1> do-while semantics as found in the classic `loop()`-step in TinkerPop2.
<2> while-do semantics as introduced in TinkerPop3. Jump to step `b` if loops greater than 1 else, `out` and jump back to `a`.   
<3> a non-predicate based jump where `out.out.out` is seen as inert code.

Finally, jump() also supports an "emit predicate." Whereby the traverser is split in two -- the traverser exists the code block as well as continues back within the code block.

[source,groovy]
gremlin> g.v(1).as('a').out.jump('a'){it.loops<2}{true}.name
==>lop
==>vadas
==>josh
==>ripple
==>lop

image::jump-step-example.png[width=500]

The first time through the jump-sequence, the vertices lop, vadas, and josh are seen. Given that the loops==0, then traverser jumps back to step `a`. However, because the emit-predicate is declared true, those vertices are emitted from jump-sequence. At step 2 (loops==1), the vertices touched are ripple and lop (Josh's created projects). Thus, they are emitted. Therefore, the solution the traversal is all vertices touched: lop, vadas, josh, ripple, and lop.

The jump()-step highlights one of the major benefits of `Traverser<T>` in TinkerPop3: the ability to arbitrarily take a traverser and place it anywhere in the Traversal step-sequence. Because a traverser maintains all the metadata associated with its particular walk, and no step maintains state information about a traverser, traverses can be moved between traversal steps as necessary without ill-effects.

[[subgraph-step]]
SubGraph Step
~~~~~~~~~~~~~

Extracting a portion of a graph from a larger one for analysis, visualization or other purposes is a fairly common use case for graph analysts and developers. The Subgraph Step provides a way to produce an edge-induced subgraph from virtually any traversal.  The following code shows how to produce the "knows" subgraph:

[source,groovy]
----
gremlin> g = TinkerFactory.createClassic()
==>tinkergraph[vertices:6 edges:6]
gremlin> sg = TinkerGraph.open() <1>
==>tinkergraph[vertices:0 edges:0]
gremlin> g.E.subGraph(sg, {it.label == 'knows'}) <2>
==>tinkergraph[vertices:3 edges:2]
gremlin> sg.E <3>
==>e[7][1-knows->2]
==>e[8][1-knows->4]
----

<1> The empty graph to which the subgraph will be generated.
<2> As this function produces "edge-induced" subgraphs, the traversal must contain edges in the path.  Those edges found in that path are evaluated by a `Predicate` function to determine if they should be copied to the subgraph in conjunction with their associated vertices.
<3> The subgraph contains only "knows" edges.

A more common subgraphing use case is to get all of the graph structure surrounding a single vertex:

[source,groovy]
----
gremlin> g = TinkerFactory.createClassic()
==>tinkergraph[vertices:6 edges:6]
gremlin> sg = TinkerGraph.open()
==>tinkergraph[vertices:0 edges:0]
gremlin> g.v(3).as('a').inE.outV.jump('a'){it.loops<3}{true}.subGraph(sg, {true})   <1>
==>tinkergraph[vertices:4 edges:4]
gremlin> sg.E
==>e[8][1-knows->4]
==>e[9][1-created->3]
==>e[11][4-created->3]
==>e[12][6-created->3]
----

<1> Starting at vertex `3`, traverse 3 steps away on in-edges, outputting all of that into the subgraph.

Match Step
~~~~~~~~~~

`MatchStep` was introduced into TinkerPop3 to support a more declarative form of pattern matching. This step extends the functionality of `table()` and `select()` with the inclusion of `match()`.

"Who created a project named 'lop' that was also created by someone who is 29 years old? Return the two creators."

image::match-step.png[width=500]

[source,java]
g.V().match("a",
  GraphTraversal.of().as("a").out("created").as("b"),
  GraphTraversal.of().as("b").has("name", "lop"),
  GraphTraversal.of().as("b").in("created").as("c"),
  GraphTraversal.of().as("c").has("age", 29))
    .select(As.of("a", "c"), v -> v.value("name")) 
// [josh, marko]
// [marko, marko]
// [peter, marko]

MatchStep brings functionality similar to SPARQL to TinkerPop. A few of the the differentiating qualities include:

[source,java]
g.V().match("a", "c"
  GraphTraversal.of().as("a").out("created").has("name","lop").as("b"), <1>
  GraphTraversal.of().as("b").in("created").has("age", 29).as("c"),
  GraphTraversal.of().as("c").out().jump("c")(v -> v.getLoops() < 2). <2>
    .out("knows").name  <3>
// josh
// vadas

<1> *Arbitrary length patterns*: `match()` is not restricted to triple patterns.
<2> *Recursion support*: `match()` supports the `jump()`-step within a pattern.
<3> *Path/pattern hybrid*: Pre and prior to a match an be a path expression and thus, both constructs supported in the same traversal.

Traversal Strategy
------------------

A `TraversalStrategy` can analyze a `Traversal` and mutate the traversal as it deems fit. This is useful in two situations:

 * There is a more efficient way to express the traversal at the TinkerPop3 level.
 * There is a more efficient way to express the traversal at the graph vendor level.

A simple TraversalStrategy is the `IdentityOptimizerTraversalStrategy` and it is a type-1 strategy defined as follows:

[source,java]
public class IdentityOptimizerTraversalStrategy implements TraversalStrategy.FinalTraversalStrategy {
    public void apply(final Traversal traversal) {
        ((List<Step>) traversal.getSteps()).stream()
                .filter(step -> step instanceof IdentityStep
                    && !TraversalHelper.isLabeled(step))
                .collect(Collectors.<Step>toList())
                .forEach(step -> TraversalHelper.removeStep(step, traversal));
    }
}

This strategy simply removes any unlabeled `IdentityStep` steps in the Traversal as `aStep().identity().identity().bStep()` is equivalent to `aStep().bStep()`. More common are type-2 strategies which are defined by graph vendors who implement TinkerPop3.

[source,java]
g.V().has("name","marko")

The expression above can be executed in a `O(|V|)` or `O(log(|V|)` fashion in <<tinkergraph-gremlin,TinkerGraph>> depending on whether there is or is not an index defined for "name."

[source,java]
TinkerGraphStepTraversalStrategy implements TraversalStrategy.FinalTraversalStrategy {
    public void apply(final Traversal traversal) {
        if (traversal.getSteps().get(0) instanceof TinkerGraphStep) {
            final TinkerGraphStep tinkerGraphStep = (TinkerGraphStep) traversal.getSteps().get(0);
            Step currentStep = tinkerGraphStep.getNextStep();
            while (true) {
                if (currentStep == EmptyStep.instance()
                    || TraversalHelper.isLabeled(currentStep)) 
                    break;
                if (currentStep instanceof HasStep) {
                    tinkerGraphStep.hasContainers.add(((HasStep) currentStep).hasContainer);
                    TraversalHelper.removeStep(currentStep, traversal);
                } else if (currentStep instanceof IntervalStep) {
                    tinkerGraphStep.hasContainers.add(((IntervalStep) currentStep).startContainer);
                    tinkerGraphStep.hasContainers.add(((IntervalStep) currentStep).endContainer);
                    TraversalHelper.removeStep(currentStep, traversal);
                } else if (currentStep instanceof IdentityStep) {
                    // do nothing
                } else {
                    break;
                }
                currentStep = currentStep.getNextStep();
            }
            tinkerGraphStep.generateHolderIterator(false);
        }
    }
}

The traversal is redefined by simply taking a chain of `has()`-steps and `interval()`-steps after `g.V()` (`TinkerGraphStep`) and providing them to `TinkerGraphStep`. Then its up to TinkerGraphStep to determine if an appropriate index exists. In the code below, review the `vertices()` method and note how if an index exists, for a particular `HasContainer`, then that index is first queried before the remaining `HasContainer` filters are serially applied.

[source,java]
----
public class TinkerGraphStep<E extends Element> extends GraphStep<E> {

    private TinkerGraph graph;
    public List<HasContainer> hasContainers = new ArrayList<>();

    public TinkerGraphStep(Traversal traversal, Class<E> returnClass, TinkerGraph graph) {
        super(traversal, returnClass);
        this.graph = graph;
        this.generateHolderIterator(false);
    }

    public void generateHolderIterator(boolean trackPaths) {
        this.starts.clear();
        if (trackPaths)
          this.starts.add(new HolderIterator(this, this.vertices()));
        else
          this.starts.add(new HolderIterator(this.vertices()));
    }

    public void clear() {
        this.starts.clear();
    }

    private Iterator<Vertex> vertices() {
        HasContainer indexedContainer = getIndexKey(Vertex.class);
        return (Iterator) ((null == indexedContainer) ?
                TinkerHelper.getVertices(this.graph).parallelStream() :
                TinkerHelper.queryVertexIndex(this.graph, indexedContainer.key, indexedContainer.value).parallelStream())
                .filter(v -> HasContainer.testAll((Vertex) v, this.hasContainers))
                .collect(Collectors.toList()).iterator();
    }

    private HasContainer getIndexKey(Class<? extends Element> indexedClass) {
        Set<String> indexedKeys = this.graph.getIndexedKeys(indexedClass);
        return this.hasContainers.stream()
                .filter(c -> indexedKeys.contains(c.key) && c.predicate.equals(Compare.EQUAL))
                .findFirst()
                .orElseGet(() -> null);
    }
}
----

Domain Specific Languages
-------------------------

The super interface of GraphTraversal is `Traversal`. It is possible for developers to create domain specific traversals by extending Traversal. For example, a `SocialTraversal` example is provided below.

[source,java]
----
public interface SocialTraversal<S, E> extends Traversal<S, E> {
   public default SocialTraversal<S, Vertex> people() {
     return (SocialTraversal) this.addStep(
       new StartStep<Vertex>(this, this.memory().<Graph>get("g").V().has("age")));
   }

   public default SocialTraversal<S, Vertex> people(String name) {
     return (SocialTraversal) this.addStep(
       new StartStep<Vertex>(this, this.memory().<Graph>get("g").V().has("name", name)));
   }

  public default SocialTraversal<S, Vertex> knows() {
    FlatMapStep<Vertex, Vertex> flatMapStep = new FlatMapStep<>(this);
    flatMapStep.setFunction(v -> v.get().out("knows"));
    return (SocialTraversal) this.addStep(flatMapStep);
  }

  public default SocialTraversal<S,String> name() {
    MapStep<Vertex,String> mapStep = new MapStep<>(this);
    mapStep.setFunction(v -> v.get().<String>getValue("name"));
    return (SocialTraversal) this.addStep(mapStep);
  }

  public static SocialTraversal of() {
    return new DefaultSocialTraversal();
  }

  public class DefaultSocialTraversal extends DefaultTraversal implements SocialTraversal {}
}
----

This traversal definition can now be used as follows.

[source,java]
g.traversal(SocialTraversal.class).people("marko").knows().name()

By extending Traversal, users can create a DSL that is respective of the semantics of their data. Instead of querying in terms of vertices/edges/properties, they can query in terms of, for example, people, their friends, and their names.

The GraphComputer API
=====================

TinkerPop3 provides two primary means of interacting with a graph: link:http://en.wikipedia.org/wiki/Online_transaction_processing[online transaction processing] (OLTP) and link:http://en.wikipedia.org/wiki/Online_analytical_processing[online analytical processing] (OLAP). OTLP-based graph systems allow the user to query the graph in real-time. However, typically, real-time performance is only possible when a local traversal is enacted. A local traversal is one that starts at a particular vertex (or small set of vertices) and only touches a small set of connected vertices (by any arbitrary path of arbitrary length). In short, OLTP queries touch a limited set of data and respond on the order of milliseconds or seconds. On the other hand, with OLAP graph processing, the entire graph is processed and thus, every vertex and edge is analyzed (some times more than once for iterative-based algorithms). Due to the amount of data being processed, the results are typically not returned in real-time and for massive graphs (i.e. graphs represented across a cluster of machines), results can take on the order of minutes or hours.

 * *OLTP*: real-time, limited data accessed, random data access, sequential processing, querying
 * *OLAP*: long running, entire data set accessed, sequential data access, parallel processing, batch processing

image::oltp-vs-olap.png[width=600]

The image above demonstrates the difference between Gremlin OLTP and Gremlin OLAP. With Gremlin OLTP, the graph is walked by moving from vertex-to-vertex via incident edges. With Gremlin OLAP, all vertices are provided a VertexProgram. The programs send messages to one another according to the topological structure of the graph as a communication network (with random message passing possible). In many respects, the messages passed are like the OLTP traversers moving from vertex-to-vertex. However, all messages are being working independent of one another, in parallel.

GraphComputer and VertexProgram
-------------------------------

In Gremlin, it is possible to have the same traversal executed either using the standard OTLP-engine or have it executed using the OLAP-engine. The difference being where the query is submitted.

[source,groovy]
g = TinkerFactory.createClassic()
==>tinkergraph[vertices:6 edges:6]
g.v(1).out('knows').name
==>vadas
==>josh
g.v(1).out('knows').name.submit(g.compute())
==>vadas
==>josh

image:bsp-diagram.png[width=400,float=right] The first traversal assumes the standard `Traversal` iterator should be `next'd()` for its results. The second traversal is submitted to `g.compute()` which is the `GraphComputer` associated with the graph `g`. GraphComputer forms the foundation of the OLAP model of TinkerPop3. GraphComputer takes a `VertexProgram`. A VertexProgram can be thought of as a piece of code that is executed at each vertex in logically parallel manner until some termination condition is met (e.g. a number of iterations have occurred, no more data is changing in the graph, etc.). A submitted VertexProgram is copied to all the vertices in the graph. Then the GraphComputer orchestrates the execution of the `VertexProgram.execute()` method on all the vertices in an link:http://en.wikipedia.org/wiki/Bulk_synchronous_parallel[bulk synchronous parallel] (BSP) fashion. The vertices are able to communicate with one another via messages. There are two types of messages in Gremlin OLAP: `LocalMessage` and `GlobalMessage`. A local message is a message to an incident edge or adjacent vertex. A global message is a message to any arbitrary element in the graph. 

image::graphcomputer.png[width=500]

NOTE: This model of graph computing was made popular by Google's link:http://googleresearch.blogspot.com/2009/06/large-scale-graph-computing-at-google.html[Pregel] graph system. In the open source world, this model is found in OLAP graph computing systems such as link:https://giraph.apache.org/[Giraph], link:https://hama.apache.org/[Hama], and link:http://faunus.thinkaurelius.com[Faunus].

[source,groovy]
g.v(1).out('knows').name.submit(g.compute())
==>vadas
==>josh

In the traversal above, the traversal is put into a newly constructed `TraversalVertexProgram` and that program is sent to each vertex in the graph. There are 3 BSP iterations and each iterations is interpreted as such:

 . If my vertex has the id 1, put a counter on my vertex.
 . For every counter at my vertex, send it to those vertices adjacent to me by a knows-edge.
 . For every counter at my vertex, send it to the name-property on my vertex.

When this returns, it returns an weighted iterator where those objects with counters are iterated and displayed for the number of counters on associated with that object.

NOTE: This model of path-based graph traversal in a BSP system was made popular by the link:http://faunus.thinkaurelius.com[Faunus] graph analytics system and originally described in link:http://markorodriguez.com/2011/04/19/local-and-distributed-traversal-engines/[Local and Distributed Traversal Engines].

A Collection of VertexPrograms
------------------------------

TinkerPop3 provides a collection of `VertexProgram`s that implement common algorithms. This section discusses the various implementations.

PageRankVertexProgram
~~~~~~~~~~~~~~~~~~~~~

Perhaps the most popular OLAP-oriented graph algorithm is link:http://en.wikipedia.org/wiki/PageRank[PageRank]. This eigenvector centrality variant was developed by Brin and Page of Google. the `VertexProgram` representation of the algorithm is presented below.

[source,java]
----
public class PageRankVertexProgram implements VertexProgram<Double> { <1>

    private MessageType.Local messageType = MessageType.Local.of(() -> GraphTraversal.of().outE()); <2>

    public static final String PAGE_RANK = Property.hidden("gremlin.pageRankVertexProgram.pageRank"); <3>
    public static final String EDGE_COUNT = Property.hidden("gremlin.pageRankVertexProgram.edgeCount");

    private static final String VERTEX_COUNT = "gremlin.pageRankVertexProgram.vertexCount";
    private static final String ALPHA = "gremlin.pageRankVertexProgram.alpha";
    private static final String TOTAL_ITERATIONS = "gremlin.pageRankVertexProgram.totalIterations";
    private static final String INCIDENT_TRAVERSAL = "gremlin.pageRankVertexProgram.incidentTraversal";

    private double vertexCountAsDouble = 1;
    private double alpha = 0.85d;
    private int totalIterations = 30;

    public PageRankVertexProgram() {

    }

   public void initialize(final Configuration configuration) { <4>
        this.vertexCountAsDouble = configuration.getDouble(VERTEX_COUNT, 1.0d);
        this.alpha = configuration.getDouble(ALPHA, 0.85d);
        this.totalIterations = configuration.getInt(TOTAL_ITERATIONS, 30);
        try {
            if (configuration.containsKey(INCIDENT_TRAVERSAL)) {
                this.messageType = MessageType.Local.of(VertexProgramHelper.deserializeSupplier(configuration, INCIDENT_TRAVERSAL));
            }
        } catch (final Exception e) {
            throw new IllegalStateException(e.getMessage(), e);
        }
    }

    public Map<String, KeyType> getComputeKeys() { <5>
        return VertexProgram.ofComputeKeys(PAGE_RANK, KeyType.VARIABLE, EDGE_COUNT, KeyType.CONSTANT);
    }

    public Class<Double> getMessageClass() {
        return Double.class;
    }

    public void setup(final GraphComputer.Globals globals) {

    }

    public void execute(final Vertex vertex, Messenger<Double> messenger, final GraphComputer.Globals globals) { <6>
        if (globals.isInitialIteration()) { <7>
            double initialPageRank = 1.0d / this.vertexCountAsDouble;
            double edgeCount = Long.valueOf(this.messageType.edges(vertex).count()).doubleValue();
            vertex.property(PAGE_RANK, initialPageRank);
            vertex.property(EDGE_COUNT, edgeCount);
            messenger.sendMessage(vertex, this.messageType, initialPageRank / edgeCount);
        } else { <8>
            double newPageRank = StreamFactory.stream(messenger.receiveMessages(vertex, this.messageType)).reduce(0.0d, (a, b) -> a + b);
            newPageRank = (this.alpha * newPageRank) + ((1.0d - this.alpha) / this.vertexCountAsDouble);
            vertex.property(PAGE_RANK, newPageRank);
            messenger.sendMessage(vertex, this.messageType, newPageRank / vertex.<Double>property(EDGE_COUNT).orElse(0.0d));
        }
    }

    public boolean terminate(final GraphComputer.Globals globals) { <9>
        return globals.getIteration() >= this.totalIterations;
    }
}
----

<1> `PageRankVertexProgram` implements `VertexProgram<Double>` because the messages it sends are Java doubles.
<2> The default path of energy propagation is via outgoing edges from the current vertex.
<3> The resulting PageRank values for the vertices are stored as a hidden property.
<4> A vertex program is contracted using an Apache `Configuration` to ensure easy dissemination across a cluster of JVMs.
<5> A vertex program must define the "compute keys" that are the properties being operated on during the computation.
<6> The "while(true)"-loop of the vertex program.
<7> Initially, each vertex is provided an equal amount of energy represented as a double.
<8> Energy is aggregated, computed on according to the PageRank algorithm, and then disseminated according to the defined `MessageType.Local`.
<9> The computation is terminated after a pre-defined number of iterations.


Gremlin Utilities
=================

Gremlin I/O
-----------

The task of getting data in and out of `Graph` instances is the job of the Gremlin I/O packages.  Gremlin I/O provides two interfaces that for reading and writing `Graph` instances: `GraphReader` and `GraphWriter`.  These interfaces expose methods that support:

* Reading and writing an entire `Graph`
* Reading and writing a `Traversal<Vertex>` as adjacency list format
* Reading and writing a single `Vertex` (with and without associated `Edge` objects)
* Reading and writing a single `Edge`

In all cases, these methods operate in the currency of `InputStream` and `OutputStream` objects, allowing graphs and their related elements to be written to and read from files, byte arrays, etc.


GraphML Reader/Writer
~~~~~~~~~~~~~~~~~~~~~

The link:http://graphml.graphdrawing.org/[GraphML] file format is a common XML-based representation of a graph.  It is widely supported by graph-related tools and libraries making it a solid interchange format for TinkerPop.  In other words, if the intent is to work with graph data in conjunction with applications outside of TinkerPop, GraphML maybe be the best choice to do that.  Common use cases might be:

* Generate a graph link:https://networkx.github.io/[NetworkX], export it with GraphML and import it to TinkerPop.
* Produce a subgraph and export it to GraphML to be consumed by and visualized in link:https://gephi.org/[Gephi].
* Migrate the data of an entire graph to a different graph database no supported by TinkerPop.

As GraphML is a specification for the serialization of an entire graph and not the individual elements of a graph, methods that support input and output of single vertices and edges are not supported.

CAUTION: GraphML is a "lossy" format in that it only supports primitive values for properties and does not have support for `Graph` variables.  It will use `toString` to serialize property values outside of those primitives.

The following code shows how to write a `Graph` instance to file called `tinkerpop-classic.xml` and then how to read that file back into a different instance:

[source,java]
----
final Graph g = TinkerFactory.createClassic();
try (final OutputStream os = new FileOutputStream("tinkerpop-classic.xml")) {
    GraphMLWriter.create().build().writeGraph(os, g);
}

final GraphReader reader = GraphMLReader.create().build();
try (final InputStream stream = new FileInputStream("tinkerpop-classic.xml")) {
    reader.readGraph(stream, g);
}
----

GraphSON Reader/Writer
~~~~~~~~~~~~~~~~~~~~~~

GraphSON is a JSON-based format that developed from earlier versions of TinkerPop.  It is not backward compatible to prior versions.  GraphSON has some support from graph-related application outside of TinkerPop, but it is generally best used in two cases:

* A text format of the graph or its elements is desired (e.g. debugging, usage in source control, etc.)
* The graph or its elements need to be consumed by code that is not JVM-based (e.g. Python, .NET, etc.)

GraphSON supports all of the `GraphReader` and `GraphWriter` interface methods and can therefore read or write an entire `Graph`, a single `Vertex` or a single `Edge`.  The following code shows how to write a `Graph` instance to file called `tinkerpop-classic.json` and then how to read that file back into a different instance:

[source,java]
----
final Graph g = TinkerFactory.createClassic();
try (final OutputStream os = new FileOutputStream("tinkerpop-classic.json")) {
    GraphSONWriter.create().build().writeGraph(os, g);
}

final GraphReader reader = GraphSONReader.create().build();
try (final InputStream stream = new FileInputStream("tinkerpop-classic.json")) {
    reader.readGraph(stream, g);
}
----

The `GraphSONReader` and `GraphSONWriter` have a number of options that they can be configured with.  One of the important options is the ability to embed type information into the output.  By embedding the types, it becomes possible to serialize a graph without losing type information that might be important when being consumed by another source.  The importance of this concept is demonstrated in the following example where a single `Vertex` is written to GraphSON using the Gremlin Console:

[source,groovy]
----
gremlin> g = TinkerFactory.createClassic()
==>tinkergraph[vertices:6 edges:6]
gremlin> w = GraphSONWriter.create().build()
==>com.tinkerpop.gremlin.structure.io.graphson.GraphSONWriter@1af146
gremlin> f = new FileOutputStream('test.txt')
==>java.io.FileOutputStream@5c8eee0f
gremlin> w.writeVertex(f, g.v(1), Direction.BOTH)
==>null
gremlin> f.close()
----

The following GraphSON example shows the output of `GraphSonWriter.writeVertex()` with associated edges:

[source,js]
----
{
    "inV": [],
    "id": 1,
    "label": "vertex",
    "type": "vertex",
    "outV": [
        {
            "inV": 3,
            "inVLabel": "vertex",
            "outVLabel": "vertex",
            "id": 9,
            "label": "created",
            "type": "edge",
            "outV": 1,
            "properties": {
                "weight": 0.4
            }
        },
        {
            "inV": 2,
            "inVLabel": "vertex",
            "outVLabel": "vertex",
            "id": 7,
            "label": "knows",
            "type": "edge",
            "outV": 1,
            "properties": {
                "weight": 0.5
            }
        },
        {
            "inV": 4,
            "inVLabel": "vertex",
            "outVLabel": "vertex",
            "id": 8,
            "label": "knows",
            "type": "edge",
            "outV": 1,
            "properties": {
                "weight": 1
            }
        }
    ],
    "properties": {
        "name": "marko",
        "age": 29
    }
}
----

The vertex properly serializes to valid JSON but note that a consuming application will not automatically know how to interpret the numeric values.  In coercing those Java values to JSON, such information is lost.  For example, it is no longer clear if the `weight` value on the edges should be read as a `Double` or an `Float`.

With a minor change to the construction of the `GraphSONWriter` the lossy nature of GraphSON can be avoided:

[source,groovy]
----
gremlin> w = GraphSONWriter.create().embedTypes(true).build()
==>com.tinkerpop.gremlin.structure.io.graphson.GraphSONWriter@350ec41e
----

In the above code, the `embedTypes` option is set to `true` and the output below shows the difference in the output:

[source,js]
----
{
    "@class": "java.util.HashMap",
    "inV": [
        "java.util.ArrayList",
        []
    ],
    "id": 1,
    "label": "vertex",
    "type": "vertex",
    "outV": [
        "java.util.ArrayList",
        [
            {
                "@class": "java.util.HashMap",
                "inV": 3,
                "inVLabel": "vertex",
                "outVLabel": "vertex",
                "id": 9,
                "label": "created",
                "type": "edge",
                "outV": 1,
                "properties": {
                    "@class": "java.util.HashMap",
                    "weight": [
                        "java.lang.Float",
                        0.4
                    ]
                }
            },
            {
                "@class": "java.util.HashMap",
                "inV": 2,
                "inVLabel": "vertex",
                "outVLabel": "vertex",
                "id": 7,
                "label": "knows",
                "type": "edge",
                "outV": 1,
                "properties": {
                    "@class": "java.util.HashMap",
                    "weight": [
                        "java.lang.Float",
                        0.5
                    ]
                }
            },
            {
                "@class": "java.util.HashMap",
                "inV": 4,
                "inVLabel": "vertex",
                "outVLabel": "vertex",
                "id": 8,
                "label": "knows",
                "type": "edge",
                "outV": 1,
                "properties": {
                    "@class": "java.util.HashMap",
                    "weight": [
                        "java.lang.Float",
                        1
                    ]
                }
            }
        ]
    ],
    "properties": {
        "@class": "java.util.HashMap",
        "name": "marko",
        "age": 29
    }
}
----

The ambiguity of components of the GraphSON is now removed by the `@class` property, which contains Java class information for the data it is associated with.  While the output is more verbose, it comes with the security of not losing type information.  While non-JVM languages won't be able to consume this information automatically, at least there is a hint as to how the values should be coerced back into the correct types in the target language.

[[gremlin-kryo]]
Kryo Reader/Writer
~~~~~~~~~~~~~~~~~~

The link:https://github.com/EsotericSoftware/kryo[Kryo] format is a binary format Graph serialization format designed for usage by JVM languages.  It is designed to be an efficient, non-lossy and represents the standard format to use when working with data inside of the TinkerPop stack.  Common use cases include:

* Migration from one Gremlin Structure implementation to another (e.g. `TinkerGraph` to `Neo4jGraph`)
* Serialization of individual graph elements to be sent over the network to another JVM.
* Backups of in-memory graphs or subgraphs.

CAUTION: When migrating between Gremlin Structure implementations, Kryo may not lose data, but it is important to consider the features of each `Graph` and whether or not the data types supported in one will be supported in the other.  Failure to do so, may result in errors.

Kryo supports all of the `GraphReader` and `GraphWriter` interface methods and can therefore read or write an entire `Graph`, a single `Vertex` or a single `Edge`.  The following code shows how to write a `Graph` instance to file called `tinkerpop-classic.gio` and then how to read that file back into a different instance:

[source,java]
----
final Graph g = TinkerFactory.createClassic();
try (final OutputStream os = new FileOutputStream("tinkerpop-classic.gio")) {
    KryoWriter.create().build().writeGraph(os, g);
}

final GraphReader reader = KryoReader.create().build();
try (final InputStream stream = new FileInputStream("tinkerpop-classic.gio")) {
    reader.readGraph(stream, g);
}
----

NOTE: The preferred extension for files names produced by Kryo `.gio`.

Graph Strategy
--------------

A Graph Strategy provides a way to expand, inspect or otherwise alter the behavior of a `Graph` implementation.  A Graph Strategy injects arbitrary functions into the `Graph` API, so that when a method call is made, the strategy functions can manipulate the default behavior of the underlying `Graph`.  TinkerPop3 is packaged with the following strategies:

* `IdGraphStrategy` - enables support for custom element identifiers for those graphs which don't otherwise support them
* `PartitionGraphStrategy` - enables support for logical graph partitioning where the `Graph` can be blinded to different parts of the total graph
* `ReadOnlyGraphStrategy` - prevents writing to the `Graph`
* `SequenceGraphStrategy` - apply multiple `GraphStrategy` implementations in sequenced ordered to a single `Graph` instance

NOTE: TinkerPop2 had the notion of "Graph Wrappers" which decorated standard `Graph` implementations with additional features.  A Graph strategy is generally analogous to that capability.

To use a `GraphStrategy` instance, use the `GraphFactory` to instantiate the `Graph` as follows:

[source,groovy]
----
gremlin> conf = new BaseConfiguration()
==>org.apache.commons.configuration.BaseConfiguration@5b40ceb
gremlin> conf.setProperty("gremlin.graph","com.tinkerpop.gremlin.tinkergraph.structure.TinkerGraph")
==>null
gremlin> g = GraphFactory.open(conf, Optional.of(new ReadOnlyGraphStrategy()))
==>[readonlygraphstrategy[tinkergraph[vertices:0 edges:0]]]
----

The above code specifies the creation of a `TinkerGraph` with the use of `ReadOnlyGraphStrategy`.  Note that the `GraphFactory` does not return a `TinkerGraph` instance.  It returns a `StrategyWrappedGraph` which is a traverser for the underlying `TinkerGraph` and the `ReadOnlyGraphStrategy`.  Since `StrategyWrappedGraph` implements the `Graph` interface, it can be used in the same manner as `TinkerGraph` or any other implementation.

[source,groovy]
----
gremlin> g.addVertex('name','stephen')
Graph uses class com.tinkerpop.gremlin.structure.strategy.ReadOnlyGraphStrategy and is therefore unmodifiable
----

The above code tries to mutate the underlying `TinkerGraph`.  Note that `ReadOnlyGraphStrategy` prevents that and throws an exception.  At any point, the `GraphStrategy` can be bypassed by getting the underlying `TinkerGraph`.

[source,groovy]
----
gremlin> bg = g.getBaseGraph()
==>tinkergraph[vertices:0 edges:0]
gremlin> bg.addVertex('name','stephen')
==>v[0]
gremlin> g.v(0l).value('name')
==>stephen
----

By getting the "base graph" (i.e. the underlying `TinkerGraph`) it is possible to mutate the graph.  The above code demonstrates that and also shows that it then possible to read back that added vertex.

Gremlin Server
--------------

Gremlin Server provides a way to remotely execute Gremlin scripts against one or more `Graph` instances hosted within it.  The benefits of using Gremlin Server include:

* Allows any Gremlin Structure-enabled graph to exist as a standalone server, which in turn enables the ability for multiple clients to communicate with the same graph database.
* Enables execution of ad-hoc queries through remotely submitted Gremlin scripts.
* Allows for the hosting of Gremlin-based DSLs (Domain Specific Language) that expand the Gremlin language to match the language of the application domain, which will help support common graph use cases such as searching, ranking, and recommendation.
* Provides a method for Non-JVM languages (e.g. Python, .NET, etc.) to communicate with the TinkerPop stack.
* Exposes numerous methods for extension and customization to include serialization options, remote commands, etc.

NOTE: Gremlin Server is essentially the replacement for link:http://rexster.tinkerpop.com[Rexster].

Communication with Gremlin Server occurs over link:http://en.wikipedia.org/wiki/WebSocket[WebSockets] and exposes a custom subprotocol for interacting with the server.  The most direct way to get started with Gremlin Server is to issue it some remote Gremlin scripts from the Gremlin Console.  To do that, first start Gremlin Server:

[source,text]
----
$bin/gremlin-server.sh config/gremlin-server-min.yaml
[INFO] GremlinServer -
         \,,,/
         (o o)
-----oOOo-(_)-oOOo-----

[INFO] GremlinServer - Configuring Gremlin Server from config/gremlin-server-min.yaml
[INFO] MetricManager - Configured Metrics Slf4jReporter configured with interval=180000ms and loggerName=com.tinkerpop.gremlin.server.Settings$Slf4jReporterMetrics
[INFO] GremlinServer$WebSocketServerInitializer - Configured application/vnd.gremlin-v1.0+kryo with com.tinkerpop.gremlin.driver.ser.KryoMessageSerializerV1d0
[INFO] GremlinServer$WebSocketServerInitializer - Configured application/vnd.gremlin-v1.0+kryo-stringd with com.tinkerpop.gremlin.driver.ser.KryoMessageSerializerV1d0
[INFO] Graphs - Graph [g] was successfully configured via [config/tinkergraph-empty.properties].
[INFO] GremlinExecutor - Getting dependencies for [[org.apache.commons, commons-math3, 3.2]]
[INFO] GremlinExecutor - Initialized gremlin-groovy ScriptEngine with scripts/generate-modern.groovy
[INFO] GremlinServer$WebSocketServerInitializer - Initialized GremlinExecutor and configured ScriptEngines.
[INFO] GremlinServer$WebSocketServerInitializer - Initialized Gremlin thread pool.  Threads in pool named with pattern gremlin-*
[INFO] GremlinServer - Gremlin Server configured with worker thread pool of 1 and boss thread pool of 1
[INFO] GremlinServer - Websocket channel started at port 8182.
----

Gremlin Server is configured by the provided link:http://www.yaml.org/[YAML] file `config/gremlin-server-min.yaml`.  That file tells Gremlin Server many things such as:

* The host and port to serve on
* Thread pool sizes
* Where to report metrics gathered by the server
* The serializers to make available
* The Gremlin `ScriptEngine` instances to expose and external dependencies to inject into them
* `Graph` instances to expose

The log messages that printed above show a number of things, but most importantly, there is a `Graph` instance named `g` that is exposed in Gremlin Server.  This graph is an in-memory TinkerGraph and was empty at the start of the server.  An initialization script at `scripts/generate-sample.groovy` was executed during startup.  It's contents are as follows:

[source,groovy]
----
include::../gremlin-server/scripts/generate-modern.groovy[]
----

This script loads the "modern" graph into the empty TinkerGraph instance, preparing it for use.  With Gremlin Server running it is now possible to issue some scripts to it for processing.  Start Gremlin Console as follows:

[source,text]
----
$ bin/gremlin.sh

         \,,,/
         (o o)
-----oOOo-(3)-oOOo-----
gremlin>
----

When the console starts, it is preconfigured to connect to a remote Gremlin Server listening on `localhost` at port `8182`:

[source,groovy]
----
gremlin> :remote
==>remote - results as text [localhost/127.0.0.1:8182]
----

The `:remote` command shown above displays the current status of the remote connection.  This command can also be used to configure a new connection and change other related settings.  To actually send a script to the server a different command is required:

[source,groovy]
----
gremlin> :> g.V.name
==>Item{resultItem=marko class=java.lang.String}
==>Item{resultItem=stephen class=java.lang.String}
==>Item{resultItem=matthias class=java.lang.String}
==>Item{resultItem=daniel class=java.lang.String}
==>Item{resultItem=gremlin class=java.lang.String}
==>Item{resultItem=blueprints class=java.lang.String}
gremlin> :> g.V.has('name','gremlin').in('uses').name
==>Item{resultItem=marko class=java.lang.String}
==>Item{resultItem=daniel class=java.lang.String}
gremlin> :> g.E.label.groupCount()
==>Item{resultItem={dependsOn=1, created=5, uses=2} class=java.lang.String}
----

The `:>` command, which is a shorthand for `:submit`, sends the script to the server to execute there.  Results are wrapped in an `Item` object which is a just a holder for each individual result.  The `class` shows the data type for the containing value.  Note that the last script sent was supposed to return a `Map`, but its `class` is `java.lang.String`.  By default, the connection is configured to only return text results.  In other words, Gremlin Server is using `toString` to serialize all results back to the console.  This enables virtually any object on the server to be returned to the console, but it doesn't allow the opportunity to work with this data in any way in the console itself.  As was stated earlier, the `:remote` command can be used to configure the connection to Gremlin Server.  One of the options available is to have results returned as `objects` instead of `text`:

[source,groovy]
----
gremlin> :remote as objects <1>
==>results as objects
gremlin> :> g.E.label.groupCount() <2>
==>Item{resultItem={dependsOn=1, created=5, uses=2} class=java.util.HashMap}
gremlin> m = _l[0].get(Map.class) <3>
==>dependsOn=1
==>created=5
==>uses=2
gremlin> m.sort{-it.value}
==>created=5
==>uses=2
==>dependsOn=1
----

<1> Tells Gremlin Server to serialize the results in a way that they can be deserialized back into an `Object` in the Console with the caveat being that the server and console both know how to serialize and deserialize the result to be returned.
<2> When the script is executed again, the `class` is no longer shown to be a `java.lang.String`.  It is instead a `java.util.HashMap`.
<3> The last result of a remote script is always stored in the reserved variable `_l`, which allows access to the `Item` and by virtue of that, the `Map` itself.

Implementations
===============

[[tinkergraph-gremlin]]
TinkerGraph-Gremlin
-------------------

[source,xml]
----
<dependency>
   <groupId>com.tinkerpop</groupId>
   <artifactId>tinkergraph-gremlin</artifactId>
   <version>3.y.z</version>
</dependency>
----

image:tinkerpop-character.png[width=100,float=left] TinkerGraph is a single machine, in-memory, non-transactional graph engine that provides both OLTP and OLAP functionality. It is deployed with TinkerPop3 and serves as the reference implementation for other vendors to study in order to understand the semantics of the various methods of the TinkerPop3 API. Constructing a simple graph in Java8 is presented below.

[source,java]
Graph g = TinkerGraph.open();
Vertex marko = g.addVertex("name","marko","age",29);
Vertex lop = g.addVertex("name","lop","lang","java");
marko.addEdge("created",lop,"weight",0.6d);

The above graph creates two vertices named "marko" and "lop" and connects them via a created-edge with a weight=0.6 property. Next, the graph can be queried as such.

[source,java]
g.V().has("name","marko").out("created").value("name")

The `g.V().has("name","marko")` part of the query can be executed in two ways.

 * A linear scan of all vertices filtering out those vertices that don't have the name "marko"
 * A `O(log(|V|))` index lookup for all vertices with the name "marko"

Given the initial graph construction in the first code block, no index was defined and thus, a linear scan is executed. However, if the graph was constructed as such, then an index lookup would be used.

[source,java]
Graph g = TinkerGraph.open();
g.createIndex("name",Vertex.class)

Each graph vendor will have different mechanism by which indices and schemas are defined. TinkerPop3 does not require any conformance in this area. In TinkerGraph, the only definitions are around indices. With other vendors, property value types, indices, edge labels, etc. may be required to be defined _a priori_ to adding data to the graph.

[[neo4j-gremlin]]
Neo4j-Gremlin
-------------

[source,xml]
----
<dependency>
   <groupId>com.tinkerpop</groupId>
   <artifactId>neo4j-gremlin</artifactId>
   <version>3.y.z</version>
</dependency>
----

image:neotech-logo.png[width=150,float=left] link:http://neotechnology.com[Neo Technology] are the developers of the link:http://neo4j.org[Neo4j graph database]. Neo4j natively supports the property graph data model. Note that Neo4j requires that the value objects in the property map of an element be Java primitives, `java.lang.String` values, or arrays of primitives and `java.lang.String` values.

[source,groovy]
----
gremlin> :use com.tinkerpop.tinkerpop3 neo4j-gremlin x.y.z
==>groovy.grape.Grape, org.apache.commons.configuration.*, com.tinkerpop.gremlin.structure.*, ... com.tinkerpop.gremlin.neo4j.structure.*
==>loaded: {disableChecksums=false, module=neo4j-gremlin, autoDownload=true, calleeDepth=4, changing=false, version=3.0.0-SNAPSHOT, group=com.tinkerpop.tinkerpop3}
gremlin> g = Neo4jGraph.open('/tmp/neo4j')
==>neo4jgraph[EmbeddedGraphDatabase [/tmp/neo4j]]
----

Note that those connecting to Neo4j Server require use of Neo4j HA.  To configure `Neo4jGraph` for "HA mode", set the `gremlin.neo4j.ha` flag to `true` in the `Configuration` object passed to `Neo4jGraph.open()`.  Note that when the flag is set (by default it is `false`), the `Neo4jGraph` instance expects HA configuration settings to be present.  As with embedded Neo4j, HA configuration keys should be prefixed with `gremlin.neo4j.conf`.  Please consult Neo4j documentation for more information on link:http://docs.neo4j.org/chunked/stable/ha.html[High Availability] configuration.

[[giraph-gremlin]]
Giraph-Gremlin
--------------

[source,xml]
----
<dependency>
   <groupId>com.tinkerpop</groupId>
   <artifactId>giraph-gremlin</artifactId>
   <version>3.y.z</version>
</dependency>
----

image:giraph-logo.png[width=75,float=left] link:http://giraph.apache.org[Giraph] is an Apache Foundation project focused on OLAP-based graph processing. Giraph makes use of the message-passing model of the distributed graph computing paradigm made popular by Google's Pregel. In Giraph, developers write "vertex programs" that get executed at each vertex in parallel. These programs can then communicate with one another in a bulk synchronous parallel (BSP) manner. This model aligns well with TinkerPop OLAP and the `GraphComputer` API. TinkerPop3 provides an implementation of `GraphComputer` that works for Giraph and is called `GiraphGraphComputer`.

IMPORTANT: image:hadoop-logo-notext.png[width=100,float=left] This section assumes that the user has a Hadoop 1.x cluster functioning. For more information on getting started with Hadoop, please see their link:http://hadoop.apache.org/docs/r1.2.1/single_node_setup.html[Single Node Setup] tutorial. Moreover, it is advisable that the reader also familiarize themselves with Giraph as well via their link:http://giraph.apache.org/quick_start.html[Getting Started] page.

Installing Giraph-Gremlin
~~~~~~~~~~~~~~~~~~~~~~~~~

To the `.bash_profile` file, add the following environmental variables (of course, be sure the directories are the respective locations on your local machine).

[source,text]
export GIRAPH_HOME=/usr/local/giraph-1.0.0
export GIRAPH_GREMLIN_HOME=/Users/marko/software/tinkerpop/tinkerpop3/giraph-gremlin/target/giraph-gremlin-3.0.0-SNAPSHOT-standalone

Properties Files
~~~~~~~~~~~~~~~~

The `GiraphGraphComputer` makes use of a properties file much like any other `GraphComputer`. However, given the relationship to Hadoop which is property heavy, it is important to look at a particular properties file. The properties file below is located at `conf/giraph-graphson.properties'.

[source,text]
gremlin.input.location=tinkerpop-classic-adjlist.ldjson
giraph.vertexInputFormatClass=
   com.tinkerpop.gremlin.giraph.structure.io.graphson.GraphSONVertexInputFormat
gremlin.output.location=output
giraph.vertexOutputFormatClass=
   com.tinkerpop.gremlin.giraph.structure.io.graphson.GraphSONVertexOutputFormat
gremlin.vertexProgram=com.tinkerpop.gremlin.process.computer.traversal.TraversalVertexProgram
gremlin.traversalSupplierClass=
   com.tinkerpop.gremlin.giraph.process.graph.example.TraversalSupplier1
giraph.minWorkers=2
giraph.maxWorkers=2

NOTE: The extension `ldjson` refers to link:http://en.wikipedia.org/wiki/Line_Delimited_JSON[line-delimitated JSON] which is the file format used by `GraphSONWriter` when writing an link:http://en.wikipedia.org/wiki/Adjacency_list[adjacency list] representation of a graph.

A review of the properties above are discussed below.

 * `gremlin.input.location`: the location of the input file(s) for Giraph to read the graph from
 * `giraph.vertexInputFormatClass`: the format that the input file(s) are represented in
 * `gremlin.output.location`: the location to write the final Giraph graph to
 * `giraph.vertexOutputFormatClass`: the format that the output file(s) should be represented in
 * `gremlin.vertexProgram`: the `VertexProgram` to disseminate to all vertices in the `GiraphGraph`
 * `gremlin.traversalSupplierClass`: for `TraversalVertexProgram`, the location of the Gremlin traversal to use
 * `giraph.minWorkers`: the minimum number of parallel workers to execute the vertices of the graph
 * `giraph.maxWorkers`: the maximum number of parallel workers to execute the vertices of the graph

IMPORTANT: The maximum number of workers can be no larger than the number of map-slots in the Hadoop cluster minus 1. For example, if the Hadoop cluster has 4 map slots, then `giraph.maxWorkers` can not be larger than 3. One map-slot is reserved for the master compute node and all other slots can be allocated as workers to execute the `VertexProgram`s on the vertices of the graph.

The above properties file states:

	The location of the graph is tinkerpop-classic-adjlist.ldjson. Interpret that file using GraphSONVertexInputFormat. Execute the TraversalVertexProgram on all vertices of the graph using the traversal defined in TraversalSupplier1. Write the computed on GiraphGraph to output/ as a GraphSONOutputFormat. Use 2 workers (thus, 3 map-slots) to execute the job.
 
Along with the properties above, the numerous link:http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-common/core-default.xml[Hadoop specific properties] can be added as needed to tune and parameterize the executed Giraph-Gremlin job on the respective Hadoop cluster.


Running a Giraph-Gremlin Job
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The properties file in the previous section stated the `gremlin.input.location` to be `tinkerpop-classic-adjlist.ldjson`. This means that this file will be looked for on link:http://en.wikipedia.org/wiki/Apache_Hadoop#Hadoop_distributed_file_system[HDFS]. Therefore, the file must be put into the filesystem.

[source,bash]
$ hadoop fs -copyFromLocal data/tinkerpop-classic-adjlist.ldjson tinkerpop-classic-adjlist.ldjson
$ hadoop fs -ls
Found 1 item
-rw-r--r--   1 marko supergroup       2387 2014-05-26 12:11 /user/marko/tinkerpop-classic-adjlist.ldjson


Next, the `TraversalSupplier1` class mentioned in the properties file is distributed with Giraph-Gremlin. It declares what Gremlin-Java traversal to execute on the loaded `GiraphGraph` by way of `TraversalVertexProgram` (the `gremlin.vertexProgram`). 

[source,java]
public class TraversalSupplier1 implements SSupplier<Traversal> {
    public Traversal get() {
        return GiraphGraph.open().V().out().out().value("name");
    }
}

To execute this traversal from the command line, use `GiraphGraphRunner` as follows:

[source,bash]
$ hadoop jar target/giraph-gremlin-3.0.0-SNAPSHOT-job.jar com.tinkerpop.gremlin.giraph.process.computer.GiraphGraphRunner conf/giraph-graphson.properties
14/05/26 12:11:35 WARN mapred.JobClient: Use GenericOptionsParser for parsing the arguments. Applications should implement Tool for the same.
14/05/26 12:11:35 INFO mapred.JobClient: Running job: job_201405261209_0001
14/05/26 12:11:36 INFO mapred.JobClient:  map 0% reduce 0%
14/05/26 12:11:57 INFO mapred.JobClient:  map 33% reduce 0%
14/05/26 12:11:58 INFO mapred.JobClient:  map 66% reduce 0%
14/05/26 12:11:59 INFO mapred.JobClient:  map 100% reduce 0%
14/05/26 12:11:59 INFO mapred.JobClient: Job complete: job_201405261209_0001
14/05/26 12:11:59 INFO mapred.JobClient: Counters: 32
14/05/26 12:11:59 INFO mapred.JobClient:   Map-Reduce Framework
14/05/26 12:11:59 INFO mapred.JobClient:     Spilled Records=0
14/05/26 12:11:59 INFO mapred.JobClient:     Map input records=3
14/05/26 12:11:59 INFO mapred.JobClient:     SPLIT_RAW_BYTES=132
14/05/26 12:11:59 INFO mapred.JobClient:     Map output records=0
14/05/26 12:11:59 INFO mapred.JobClient:     Total committed heap usage (bytes)=347078656
14/05/26 12:11:59 INFO mapred.JobClient:   Giraph Timers
14/05/26 12:11:59 INFO mapred.JobClient:     Total (milliseconds)=2718
14/05/26 12:11:59 INFO mapred.JobClient:     Superstep 2 (milliseconds)=58
14/05/26 12:11:59 INFO mapred.JobClient:     Shutdown (milliseconds)=361
14/05/26 12:11:59 INFO mapred.JobClient:     Superstep 1 (milliseconds)=130
14/05/26 12:11:59 INFO mapred.JobClient:     Input superstep (milliseconds)=886
14/05/26 12:11:59 INFO mapred.JobClient:     Superstep 0 (milliseconds)=317
14/05/26 12:11:59 INFO mapred.JobClient:     Setup (milliseconds)=882
14/05/26 12:11:59 INFO mapred.JobClient:     Superstep 3 (milliseconds)=47
14/05/26 12:11:59 INFO mapred.JobClient:     Superstep 4 (milliseconds)=33
14/05/26 12:11:59 INFO mapred.JobClient:   File Input Format Counters
14/05/26 12:11:59 INFO mapred.JobClient:     Bytes Read=0
14/05/26 12:11:59 INFO mapred.JobClient:   Giraph Stats
14/05/26 12:11:59 INFO mapred.JobClient:     Aggregate finished vertices=0
14/05/26 12:11:59 INFO mapred.JobClient:     Aggregate edges=0
14/05/26 12:11:59 INFO mapred.JobClient:     Sent messages=0
14/05/26 12:11:59 INFO mapred.JobClient:     Current workers=2
14/05/26 12:11:59 INFO mapred.JobClient:     Last checkpointed superstep=0
14/05/26 12:11:59 INFO mapred.JobClient:     Current master task partition=0
14/05/26 12:11:59 INFO mapred.JobClient:     Superstep=5
14/05/26 12:11:59 INFO mapred.JobClient:     Aggregate vertices=6
14/05/26 12:11:59 INFO mapred.JobClient:   FileSystemCounters
14/05/26 12:11:59 INFO mapred.JobClient:     HDFS_BYTES_READ=2519
14/05/26 12:11:59 INFO mapred.JobClient:     FILE_BYTES_WRITTEN=235461
14/05/26 12:11:59 INFO mapred.JobClient:     HDFS_BYTES_WRITTEN=3354
14/05/26 12:11:59 INFO mapred.JobClient:   Job Counters
14/05/26 12:11:59 INFO mapred.JobClient:     Launched map tasks=3
14/05/26 12:11:59 INFO mapred.JobClient:     SLOTS_MILLIS_REDUCES=0
14/05/26 12:11:59 INFO mapred.JobClient:     SLOTS_MILLIS_MAPS=28105
14/05/26 12:11:59 INFO mapred.JobClient:   File Output Format Counters
14/05/26 12:11:59 INFO mapred.JobClient:     Bytes Written=0

IMPORTANT: The only way to currently execute a Giraph-Gremlin job is via the terminal (as demonstrated above) or programmatically via Java or Groovy. Direct Gremlin-Groovy support via `:remote` should be coming soon.

Understanding the Output
~~~~~~~~~~~~~~~~~~~~~~~~

When job completes, the output is written to `gremlin.output.location` which was defined in the properties file as `output`. Realize that Hadoop will write the output according to the number of workers. Given that there were 2 workers, there are two files in `output`.

[source,bash]
$ hadoop fs -ls output
Found 4 items
-rw-r--r--   1 marko supergroup          0 2014-05-27 09:51 /user/marko/output/_SUCCESS
drwxr-xr-x   - marko supergroup          0 2014-05-27 09:50 /user/marko/output/_logs
-rw-r--r--   1 marko supergroup       1840 2014-05-27 09:50 /user/marko/output/part-m-00001
-rw-r--r--   1 marko supergroup       1514 2014-05-27 09:50 /user/marko/output/part-m-00002

The part-files can merged out of HDFS and into a single file on the local drive  using `-getmerge`.

[source,bash]
$ hadoop fs -getmerge output tinkerpop-classic-adjlist-2.ldjson

[source,js]
{"inE":[],"outE":[{"inV":3,"inVLabel":"vertex","outVLabel":"vertex","id":9,"label":"created","type":"edge","outV":1,"hiddens":{},"properties":{"weight":0.4}},{"inV":2,"inVLabel":"vertex","outVLabel":"vertex","id":7,"label":"knows","type":"edge","outV":1,"hiddens":{},"properties":{"weight":0.5}},{"inV":4,"inVLabel":"vertex","outVLabel":"vertex","id":8,"label":"knows","type":"edge","outV":1,"hiddens":{},"properties":{"weight":1.0}}],"id":1,"label":"vertex","type":"vertex","hiddens":{},"properties":{"name":"marko","age":29}}
{"inE":[{"inV":2,"inVLabel":"vertex","outVLabel":"vertex","id":7,"label":"knows","type":"edge","outV":1,"hiddens":{},"properties":{"weight":0.5}}],"outE":[],"id":2,"label":"vertex","type":"vertex","hiddens":{},"properties":{"name":"vadas","age":27}}
{"inE":[{"inV":3,"inVLabel":"vertex","outVLabel":"vertex","id":9,"label":"created","type":"edge","outV":1,"hiddens":{},"properties":{"weight":0.4}},{"inV":3,"inVLabel":"vertex","outVLabel":"vertex","id":11,"label":"created","type":"edge","outV":4,"hiddens":{},"properties":{"weight":0.4}},{"inV":3,"inVLabel":"vertex","outVLabel":"vertex","id":12,"label":"created","type":"edge","outV":6,"hiddens":{},"properties":{"weight":0.2}}],"outE":[],"id":3,"label":"vertex","type":"vertex","hiddens":{},"properties":{"name":"lop","lang":"java"}}
{"inE":[{"inV":4,"inVLabel":"vertex","outVLabel":"vertex","id":8,"label":"knows","type":"edge","outV":1,"hiddens":{},"properties":{"weight":1.0}}],"outE":[{"inV":5,"inVLabel":"vertex","outVLabel":"vertex","id":10,"label":"created","type":"edge","outV":4,"hiddens":{},"properties":{"weight":1.0}},{"inV":3,"inVLabel":"vertex","outVLabel":"vertex","id":11,"label":"created","type":"edge","outV":4,"hiddens":{},"properties":{"weight":0.4}}],"id":4,"label":"vertex","type":"vertex","hiddens":{},"properties":{"name":"josh","age":32}}
{"inE":[{"inV":5,"inVLabel":"vertex","outVLabel":"vertex","id":10,"label":"created","type":"edge","outV":4,"hiddens":{},"properties":{"weight":1.0}}],"outE":[],"id":5,"label":"vertex","type":"vertex","hiddens":{},"properties":{"name":"ripple","lang":"java"}}
{"inE":[],"outE":[{"inV":3,"inVLabel":"vertex","outVLabel":"vertex","id":12,"label":"created","type":"edge","outV":6,"hiddens":{},"properties":{"weight":0.2}}],"id":6,"label":"vertex","type":"vertex","hiddens":{},"properties":{"name":"peter","age":35}}

Looking particularly at the lop-vertex:

[source,js]
{
 "inE":[
  {"inV":3,"inVLabel":"vertex","outVLabel":"vertex","id":0,
   "label":"created","type":"edge","outV":1,"hiddens":{},"properties":{"weight":0.4}},
  {"inV":3,"inVLabel":"vertex","outVLabel":"vertex","id":1,
   "label":"created","type":"edge","outV":4,"hiddens":{},"properties":{"weight":0.4}},
  {"inV":3,"inVLabel":"vertex","outVLabel":"vertex","id":2,
   "label":"created","type":"edge","outV":6,"hiddens":{},"properties":{"weight":0.2}}
 ],
 "id":3,
 "label":"vertex",
 "type":"vertex",
 "hiddens":{
  "gremlin.traversalVertexProgram.traversalTracker": {
    "previousObjectTracks":{"lop":1},
    "graphTracks":{},
    "objectTracks":{},
    "doneGraphTracks":{},
    "doneObjectTracks":{"lop":1}}
  },
 "outE":[],
 "properties":{
  "name":"lop",
  "lang":"java"
}

In the hidden properties of the vertex is a property called `gremlin.traversalVertexProgram.traversalTracker`. The `doneObjectTracks`-key states that there is a single counter on the `String` "lop". An analogous result is found on "ripple." This is the correct result of the computation as:

[source,groovy]
gremlin> g = TinkerFactory.createClassic()
==>tinkergraph[vertices:6 edges:6]
gremlin> g.V.out.out.name
==>ripple
==>lop

IMPORTANT: GraphSON is a verbose I/O format. It is useful for demonstrations because it is a human-readable format, but in practice is not used for large-scale computations. Instead, <<gremlin-kryo,GremlinKryo>> is used.

A PageRank Example
~~~~~~~~~~~~~~~~~~

image::pagerank-logo.png[width=300]

The classic link:http://en.wikipedia.org/wiki/PageRank[PageRank] centrality algorithm can be executed over TinkerPop classic by simply updating the properties file.

[source,text]
gremlin.input.location=tinkerpop-classic-adjlist.ldjson
giraph.vertexInputFormatClass=
   com.tinkerpop.gremlin.giraph.structure.io.graphson.GraphSONVertexInputFormat
gremlin.output.location=output
giraph.vertexOutputFormatClass=
   com.tinkerpop.gremlin.giraph.structure.io.graphson.GraphSONVertexOutputFormat
gremlin.vertexProgram=com.tinkerpop.gremlin.process.computer.ranking.PageRankVertexProgram
giraph.minWorkers=2
giraph.maxWorkers=2

A `hadoop fs -getmerge output tinkerpop-classic-adjlist-2.ldjson` yields the computed graph which has the PageRank values of every vertex as a hidden property. Vertex 4 ("josh") is isolated below:

[source,js]
{
 "inE":[
  {"inV":4,"inVLabel":"vertex","outVLabel":"vertex","id":8,
    "label":"knows","type":"edge","outV":1,"hiddens":{},"properties":{"weight":1.0}}
 ],
 "outE":[
  {"inV":5,"inVLabel":"vertex","outVLabel":"vertex","id":10,
    "label":"created","type":"edge","outV":4,"hiddens":{},"properties":{"weight":1.0}},
  {"inV":3,"inVLabel":"vertex","outVLabel":"vertex","id":11,
    "label":"created","type":"edge","outV":4,"hiddens":{},"properties":{"weight":0.4}}
 ],
 "id":4,
 "label":"vertex",
 "type":"vertex",
 "hiddens":{
  "gremlin.pageRankVertexProgram.pageRank":0.19250000000000003,
  "gremlin.pageRankVertexProgram.edgeCount":2.0
 },
 "properties":{
  "name":"josh",
  "age":32
 }
}

Conclusion
==========

The world that we know, you and me, is but a subset of the world that Gremlin has weaved within The TinkerPop. Gremlin has constructed a fully connected graph and only the subset that makes logical sense to our traversing thoughts is the fragment we have come to know and have come to see one another within. But there are many more out there, within other webs of logics unfathomed. From any thought, every other thought, we come to realize that which is -- The TinkerPop.

Acknowledgements
================

image::yourkit-logo.png[]

YourKit supports the TinkerPop open source project with its full-featured Java Profiler. YourKit, LLC is the creator of innovative and intelligent tools for profiling Java and .NET applications. YourKit's leading software products: link:http://www.yourkit.com/java/profiler/index.jsp[YourKit Java Profiler] and link:http://www.yourkit.com/.net/profiler/index.jsp[YourKit .NET Profiler]