image::tinkerpop3-logo.png[width=500]


:toc-position: left

// This directive does nothing.
// Seems the highlighter must be configured in the pom (?)
// :source-highlighter: coderay


The Third Incarnation of The TinkerPop
======================================

The TinkerPop is the reality that begot Gremlin and all that Gremlin has ever known -- as well as that which is no knowledge. In *TinkerPop0*, Gremlin found himself alone in a world of reference as he moved about trying to understand why this structure existed and for what reason. Far is far and near is near for Gremlin. For The TinkerPop, this is true as well, but also west is right, down is forward, and Gremlin is The TinkerPop, as well as not. When will he realize this?

image::gremlin-logo.png[width=400]

Confused by his wanders, for *TinkerPop1* Gremlin machined his friends Blueprints, Pipes, Frames, Furnace, and Rexster. However, The TinkerPop is elusive and difficult to realize through mechanical means. Gremlin thought that perhaps if the machines were more precise, they will allow him to more quickly, move through The TinkerPop and ultimately, understand it completely. With a little help from his friends, Gremlin traverses and traverses but when he is here, he is not there and thus, not fully with The TinkerPop which is everywhere.

image::gremlin-and-friends.png[width=600]

Perhaps if he faster then he can be at all vertices at "once." In *TinkerPop2*, Gremlin created various optimizations to his machines. However, regardless of his haste, he is always stuck within his reference structure, patterned by his graph of associations that move him about --- ping, pong, ping, pong (a mere sliver of that which is The TinkerPop). Unsatisfied with his approach to The TinkerPop, he contemplated what TinkerPop3 would be. Gremlin reviewed the situation with his friends -- long discussions ensued.

image::tinkerpop-reading.png[width=500]

His final push, his final emphatic expression of himself made him rethink his approach. For his third attempt he gathered his friends...

image::tinkerpop3-splash.png[width=500]

...and united them in such a way that their very nature became his. For *TinkerPop3* is the Gremlin and all the world will realize that it is all the world.

image::gremlintron.png[width=500]

Graph Computing with TinkerPop3
===============================

A link:http://en.wikipedia.org/wiki/Graph_(data_structure)[graph] is a data structure composed of vertices (nodes, dots) and edges (arcs, lines). When modeling a graph in a computer and applying it to modern data sets and practices, the generic mathematically-oriented, binary graph is extended to support both labels and key/value properties. This structure is known as a property graph. More formally, it is a directed, binary, attributed multi-graph. An example property graph is diagrammed below. This graph example will be used extensively throughout the documentation and is called "TinkerPop Classic" as it is the original demo graph distributed with TinkerPop0 in 2009.

TIP: The TinkerPop classic graph is available with <<tinkergraph-reference-implementation,TinkerGraph>> via `TinkerFactory.createClassic()`. TinkerGraph is the reference implementation of TinkerPop3 and is used throughout the documentation.

.TinkerPop Classic
image::tinkerpop-classic.png[width=500]

TinkerPop3 is the third incarnation of a graph computing framework now built atop Java8. In graph computing, like computing in general, a distinction is made between *structure* (graph) and *process* (traversal). The structure of the graph is the data model defined by a vertex/edge/property topology. The process of the graph is the means by which the structure is analyzed.

.Primary components of the TinkerPop3 *structure* API 
 * `Graph`: maintains a set of vertices and edges, and access to administrative functions and transactions.
 * `Element`: maintains a collection of properties and a string label. 
  ** `Vertex`: extends Element and maintains a set of incoming and outgoing edges.
  ** `Edge`: extends Element and maintains an incoming and outgoing vertex.
 * `Property<V>`: a string key and a V value.

.Primary components of the TinkerPop3 *process* API
 * `Traversal`: a functional data flow process.
  ** `GraphTraversal`: a traversal that is oriented towards the semantics of the raw graph (i.e. vertices, edges, etc.)
 * `VertexProgram`: an body of code to be executed by all vertices in a logically parallel fashion.

The purpose of this documentation is to describe this dichotomy at depth and in doing so, explain how to leverage TinkerPop3 for the sole purpose of vendor-agnostic graph computing.

The Graph Structure
-------------------

The classic TinkerPop graph can be created with the following Java8 code.

[source,java]
Graph g = TinkerGraph.open();
Vertex marko = g.addVertex(Element.ID, 1, "name", "marko", "age", 29);
Vertex vadas = g.addVertex(Element.ID, 2, "name", "vadas", "age", 27);
Vertex lop = g.addVertex(Element.ID, 3, "name", "lop", "lang", "java");
Vertex josh = g.addVertex(Element.ID, 4, "name", "josh", "age", 32);
Vertex ripple = g.addVertex(Element.ID, 5, "name", "ripple", "lang", "java");
Vertex peter = g.addVertex(Element.ID, 6, "name", "peter", "age", 35);
marko.addEdge("knows", vadas, Element.ID, 7, "weight", 0.5f);
marko.addEdge("knows", josh, Element.ID, 8, "weight", 1.0f);
marko.addEdge("created", lop, Element.ID, 9, "weight", 0.4f);
josh.addEdge("created", ripple, Element.ID, 10, "weight", 1.0f);
josh.addEdge("created", lop, Element.ID, 11, "weight", 0.4f);
peter.addEdge("created", lop, Element.ID, 12, "weight", 0.2f);

In the above code all the vertices are created first and then their respective edges. There are two reserved keys: id (`Element.ID`) and label (`Element.LABEL`). When any of these, along with a set of other key value pairs is provided to `Graph.addVertex(Object...)` or `Graph.addEdge(String,Vertex,Object...)`, the respective element is created along with the provided key/value pair properties amended. 

CAUTION: Many graph vendors do not allow the user to specify an element ID and in such cases, the element ID key/value is ignored.

Annotated Lists
~~~~~~~~~~~~~~~

The values of a property can be any arbitrary `Object` as long as the object type is supported by the underlying graph vendor. One particular special object that has been introduced into TinkerPop3 is the `AnnotatedList`. AnnotatedLists are useful in systems that support auditing and provenance. In such instances, a particular property key will want to be associated with a list of values. For example, assume that the locations of a person are a property on a vertex. This can be represented solely using a `List<String>`, but in many instances, other metadata (i.e. annotations) may be desired, because a person could have lived in various locations over time.

image::annotated-list.png[width=600]

In TinkerPop3, an annotated list is created as follows in Java8.

[source,java]
Graph g = TinkerGraph.open()
Vertex marko = g.addVertex(Element.ID, 1, Element.LABEL, "person")
AnnotatedList locations = marko.setProperty("locations",AnnotatedList.make()).get()
locations.addValue("san diego","startTime",1997,"endTime",2001)
locations.addValue("santa cruz","startTime",2001,"endTime",2004)
locations.addValue("brussels","startTime",2004,"endTime",2005)
locations.addValue("santa fe","startTime",2005,"endTime",2014)
System.out.println(locations)
// [san diego, santa cruz, ...]
names.annotatedValues().forEach(System.out::println)
// [san diego:{startTime=1997, endTime=2001}]
// [santa cruz:{startTime=2001, endTime=2004}]
// [brussels:{startTime=2004, endTime=2005}]
// [santa fe:{startTime=2005, endTime=2014}]
locations.annotatedValues().has('startTime',T.gt,2002).value().forEach(System.out::println)
// brussels
// santa fe

The TinkerPop Modern graph is available via `TinkerFactory.createModern()` and provides a new demonstration graph. This graph provides examples of an annotated list.

.TinkerPop Modern
image::tinkerpop-modern.png[width=600]


The Graph Process
-----------------

The primary way in which graphs are processed is by means of graph traversals. A graph traversal can be spawed from a Graph, Vertex, or Edge. For example, Graph provides two traversal methods.

 . `Graph.V()`: generates a traversal starting at all vertices in the graph. 
 . `Graph.E()`: generates a traversal starting at all edges in the graph.

The return type of `V()` and `E()` is `GraphTraversal`. A GraphTraversal maintains numerous methods that return GraphTraversal. In this way, a GraphTraversal supports function composition and implements `Iterator` and `Iterable`. Each method of GraphTraversal is called a step and each step modulates the results of the previous step in one of three ways.

 . `map`: transform the incoming object to another object
 . `flatMap`: transform the incoming object to an iterator of other objects
 . `filter`: allow or disallow the object from proceeding to the next step

NOTE: Both map and filter can be represented as flatMap. Map can return an iterator with a single object in it. Filter can return an iterator with a single object in it or no object at all. Thus, flatMap is the most general construct -- "turn the incoming object into an iterator of objects."

Given the classic TinkerPop graph, the following query will return the names of all the people that Marko knows. The following query is demonstrated using the Gremlin-Groovy REPL. This is accessible via `bin/gremlin.sh` (or `bin/gremlin.bat` for Windows users).

TIP: image:groovy-logo.png[width=175,float=left] Gremlin-Groovy leverages the link:http://groovy.codehaus.org/[Groovy 2.x language] to express Gremlin traversals. One of the major benefits of Groovy is the inclusion of a runtime console that makes it easy for developers to practice with the Gremlin language and for production users to connect to their graph and execute traversals in an interactive manner. Moreover, Gremlin-Groovy provides various syntax simplifications.

CAUTION: In the code examples presented throughout this documentation, either Gremlin-Java8 or Gremlin-Groovy is used. Usually which derivative of Gremlin is being used is made explicit in the text, however, if not, a simple mouse over on the code block will state the language as either "JAVA" or "GROOVY."


[source,groovy]
----
$ bin/gremlin.sh

         \,,,/
         (o o)
-----oOOo-(3)-oOOo-----
gremlin> g.V().has('name','marko').out('knows').name
==>vadas
==>josh
----

Or, if the vertex marko is already realized with a direct reference pointer, then the traversal can be spawed off that vertex.

[source,groovy]
marko.out('knows').name

.The Name of The People That Marko Knows
image::tinkerpop-classic-ex1.png[width=500]

Again, all steps extend either map, flatMap, or filter. Thus, the traversal above can be written in its generic form as:

[source,groovy]
marko
  .filter{it.get()['name'] == 'marko'}
  .flatMap{it.get().out('knows')}
  .map{it.get()['name']}
==>vadas
==>josh

The steps map, flatMap, and filter take a link:http://en.wikipedia.org/wiki/Anonymous_function[lambda function] (i.e. an anonymous function or closure). For map, the function must return an object. For flatMap, the function must return an iterator of objects. For filter, the function is a predicate that returns either true or false. The lambdas introduced by Java8 are supported in TinkerPop3.

NOTE: Gremlin-Java is much more aligned with Gremlin-Groovy in TinkerPop3 than it ever was before. In TinkerPop0 through TinkerPop2, Gremlin-Java was extremely verbose due to the simulation of lambdas via anonymous inner classes.  

Traversal Mechanics
~~~~~~~~~~~~~~~~~~~

When a traversal is executed, the source of the traversal is on the left of the expression (e.g. vertex 1), the steps are the middle of the traversal (e.g. `out("knows")` and `value("name")`), and the result is "traversal.next()'d" out of the right of the traversal (e.g. "vadas" and "josh").

image::traversal-mechanics.png[width=500]

In TinkerPop3, the objects propagating through the traversal are wrapped in a `Holder<T>`. The holder concept is new as of TinkerPop3 and provides the means by which steps remain stateless. A holder maintains all the metadata about the traversal -- e.g., how many times the object has gone through a loop, the path history of the object, etc. This data can be accessed by a step:

[source,groovy]
marko.out('knows').name.path
==>[v[1], v[2], vadas]
==>[v[1], v[4], josh]

In the general form of the expression, the input to the functions map, flatMap, and filter are a `Holder<T>`. Hence, the reason, the general form lambdas start with a `v.get()` (i.e. "get the raw object of the holder containing a vertex"). The general form of path-step demonstrates how the metadata of the holder is accessed without accessing the raw object. 

[source,groovy]
marko
  .filter{it.get()['name'] == 'marko'}
  .flatMap{it.get().out('knows')}
  .map{it.get()['name']}
  .map{it.getPath()}
==>[v[1], v[2], vadas]
==>[v[1], v[4], josh]

CAUTION: Path calculation is costly in terms of space as an array of previously seen objects is stored in each path of the respective holder. Thus, traversal optimizers analyze the traversal to determine if path metadata is accessed. If not, then path calculations are turned off.

[[tinkergraph-reference-implementation]]
TinkerGraph
-----------

image:tinkerpop-character.png[width=100,float=left] TinkerGraph is a single machine, in-memory, non-transactional graph engine that provides both OLTP and OLAP functionality. It is deployed with TinkerPop3 and serves as the reference implementation for other vendors to study in order to understand the semantics of the various methods of the TinkerPop3 API. Constructing a simple graph in Java8 is presented below.

[source,java]
Graph g = TinkerGraph.open();
Vertex marko = g.addVertex("name","marko","age",29);
Vertex lop = g.addVertex("name","lop","lang","java");
marko.addEdge("created",lop,"weight",0.6d);

The above graph creates two vertices named "marko" and "lop" and connects them via a created-edge with a weight=0.6 property. Next, the graph can be queried as such.

[source,java]
g.V().has("name","marko").out("created").value("name")

The `g.V().has("name","marko")` part of the query can be executed in two ways.

 * A linear scan of all vertices filtering out those vertices that don't have the name "marko"
 * A `O(log(|V|))` index lookup for all vertices with the name "marko"

Given the initial graph construction in the first code block, no index was defined and thus, a linear scan is executed. However, if the graph was constructed as such, then an index lookup would be used.

[source,java]
Graph g = TinkerGraph.open();
g.createIndex("name",Vertex.class)

Each graph vendor will have different mechanism by which indices and schemas are defined. TinkerPop3 does not require any conformance in this area. In TinkerGraph, the only definitions are around indices. With other vendors, property value types, indices, edge labels, etc. may be required to be defined _a priori_ to adding data to the graph.


The Traversal API
=================

Graph Traversal Steps
---------------------

The primary Traversal is `GraphTraversal`, and graph traversals can be spawned off of Graph, Vertex, and Edge. A list of all the steps are provided below along with a description. Note that a Traversal is defined as `Traversal<S,E>` where the `S` stands for start and the `E` stands for end. Likewise, each `Step<S,E>` maintains the same convention.

. Transform: S &rarr; E
 * `map(function)`: apply the provided function to S and emit the result as E.
 * `flatMap(function)`: apply the provided function to S and iterate the return iterator as a stream of E objects.
 * `identity`: emit S as E directly.
 * `out(string…)`: the S vertex is mapped to its string[]-adjacent E vertices.
 * ... 
. Filter: S &rarr; S &cup; &empty;
 * `filter(predicate)`: apply the predicate to S and if true, emit S else emit nothing.
 * `dedup`: if S has not been seen before emit it, else do not emit it.
 * ...
. SideEffect: S &rarr; S
 * `sideEffect(consumer)`: apply the consumer to S and then emit S.
 * …
. Branch: S &rarr; S
 * `jump(string)` : teleport S to the labeled string-labeled step in the traversal.
 * ...


Traversal Optimizers
--------------------

An `Optimizer` can analyze a `Traversal` and mutate the traversal as it deems fit. This is useful in two situations:

 * There is a more efficient way to express the traversal at the TinkerPop3 level.
 * There is a more efficient way to express the traversal at the graph vendor level.

An extremely simply Optimizer is the `IdentityOptimizer` and it is a type-1 optimizer defined as follows:

[source,java]
public class IdentityOptimizer implements Optimizer.FinalOptimizer {
    public void optimize(final Traversal traversal) {
        ((List<Step>) traversal.getSteps()).stream()
                .filter(step -> step instanceof IdentityStep
                    && !TraversalHelper.isLabeled(step))
                .collect(Collectors.<Step>toList())
                .forEach(step -> TraversalHelper.removeStep(step, traversal));
    }
}

This optimizer simply removes any unlabeled `IdentityStep` in the Traversal as `aStep().identity().identity().bStep()` is equivalent to `aStep().bStep()`. More common are type-2 optimizers which are defined by graph vendors who implement TinkerPop3.

[source,java]
g.V().has("name","marko")

The expression above can be executed in a `O(|V|)` or `O(log(|V|)` fashion in TinkerGraph depending on whether there is or is not an index defined for "name."

[source,java]
----------------------------
include::tinkergraph-gremlin/src/main/java/com/tinkerpop/gremlin/tinkergraph/process/graph/util/optimizers/TinkerGraphStepOptimizer.java[method=void optimize(Traversal)]
----------------------------

The traversal is redefined by simply taking an chain of `has()`-steps and `interval()`-steps after `g.V()` (`TinkerGraphStep`) and providing them to `TinkerGraphStep`. Then its up to TinkerGraphStep to determine if an appropriate index exists. In the code below, review `vertices()` and note how if an index exists, for a particular `HasContainer`, then that index is first queried before the remaining `HasContainer` filters are serially applied.

[source,java]
----
public class TinkerGraphStep<E extends Element> extends GraphStep<E> {

    private TinkerGraph graph;
    public List<HasContainer> hasContainers = new ArrayList<>();

    public TinkerGraphStep(Traversal traversal,
                           Class<E> returnClass,
                           TinkerGraph graph) {
        super(traversal, returnClass);
        this.graph = graph;
        this.generateHolderIterator(false);
    }

    public void generateHolderIterator(boolean trackPaths) {
        this.starts.clear();
        if (trackPaths)
          this.starts.add(new HolderIterator(this, this.vertices()));
        else
          this.starts.add(new HolderIterator(this.vertices()));
    }

    public void clear() {
        this.starts.clear();
    }

    private Iterator<Vertex> vertices() {
        HasContainer indexedContainer = getIndexKey(Vertex.class);
        return (Iterator) ((null == indexedContainer) ?
                TinkerHelper.getVertices(this.graph).parallelStream() :
                TinkerHelper.queryVertexIndex(this.graph, 
                    indexedContainer.key, 
                    indexedContainer.value).parallelStream())
                .filter(v -> HasContainer.testAll((Vertex) v, this.hasContainers))
                .collect(Collectors.toList()).iterator();
    }

    private HasContainer getIndexKey(Class<? extends Element> indexedClass) {
        Set<String> indexedKeys = this.graph.getIndexedKeys(indexedClass);
        return this.hasContainers.stream()
                .filter(c -> indexedKeys.contains(c.key)
                    && c.predicate.equals(Compare.EQUAL))
                .findFirst()
                .orElseGet(() -> null);
    }
}
----


Domain Specific Languages
-------------------------

The super interface of GraphTraversal is `Traversal`. It is possible for developers to create domain specific traversals by extending Traversal. For example, a `SocialTraversal` example is provided below.

[source,java]
----
public interface SocialTraversal<S, E> extends Traversal<S, E> {
   public default SocialTraversal<S, Vertex> people() {
     return (SocialTraversal) this.addStep(
       new StartStep<Vertex>(this, this.memory().<Graph>get("g").V().has("age")));
   }

   public default SocialTraversal<S, Vertex> people(String name) {
     return (SocialTraversal) this.addStep(
       new StartStep<Vertex>(this, this.memory().<Graph>get("g").V().has("name", name)));
   }

  public default SocialTraversal<S, Vertex> knows() {
    FlatMapStep<Vertex, Vertex> flatMapStep = new FlatMapStep<>(this);
    flatMapStep.setFunction(v -> v.get().out("knows"));
    return (SocialTraversal) this.addStep(flatMapStep);
  }

  public default SocialTraversal<S,String> name() {
    MapStep<Vertex,String> mapStep = new MapStep<>(this);
    mapStep.setFunction(v -> v.get().<String>getValue("name"));
    return (SocialTraversal) this.addStep(mapStep);
  }

  public static SocialTraversal of() {
    return new DefaultSocialTraversal();
  }

  public class DefaultSocialTraversal extends DefaultTraversal implements SocialTraversal {}
}
----

This traversal definition can now be used as follows.

[source,java]
g.traversal(SocialTraversal.class).people("marko").knows().name()

By extending Traversal, users can create a DSL that is respective of the semantics of their data. Instead of querying in terms of vertices/edges/properties, they can query in terms of, for example, people, their friends, and their names.

The GraphComputer API
=====================

TinkerPop3 provides two primary means of interacting with a graph: link:http://en.wikipedia.org/wiki/Online_transaction_processing[online transaction processing] (OLTP) and link:http://en.wikipedia.org/wiki/Online_analytical_processing[online analytical processing] (OLAP). OTLP-based graph systems allow the user to query the graph in real-time. However, typically, real-time performance is only possible when a local traversal is enacted. A local traversal is one that starts at a particular vertex (or small set of vertices) and only touches a small set of connected vertices (by any arbitrary path of arbitrary length). In short, OLTP queries touch a limited set of data and respond on the order of milliseconds or seconds. On the other hand, with OLAP graph processing, the entire graph is processed and thus, every vertex and edge is analyzed (some times more than once for iterative-based algorithms). Due to the amount of data being processed, the results are typically not returned in real-time and for massive graphs (i.e. graphs represented across a cluster of machines), results can take on the order of minutes or hours.

 * *OLTP*: real-time, limited data accessed, random data access, sequential processing, querying
 * *OLAP*: long running, entire data set accessed, sequential data access, parallel processing, batch processing

image::oltp-vs-olap.png[width=600]

The image above demonstrates the difference between Gremlin OLTP and Gremlin OLAP. With Gremlin OLTP, the graph is walked by moving from vertex-to-vertex via incident edges and in effect return various computations of that traversal. For example, the elements at the end of the path, the full path traversed, or some side-effect such as the count or various groupings of the objects seen during the traversal. Thus, each step (1,2,3), is a movement along this referential structure. With Gremlin OLAP, all vertices are provided a VertexProgram. That program runs in parallel to all other programs with the programs sending messages to one another according to the topological structure of the graph as a communication network (with random message passing possible). In many respects, the messages passed are like the OLTP traversers moving from vertex-to-vertex however, all messages are being working independent of one another, in parallel.

GraphComputer and VertexProgram
-------------------------------

In Gremlin, it is possible to express to have the same traversal executed either using the standard OTLP-engine or have it executed using the OLAP-engine. The difference being where the query is submitted.

[source,groovy]
g = TinkerFactory.createClassic()
==>tinkergraph[vertices:6 edges:6]
g.v(1).out('knows').name
==>vadas
==>josh
g.v(1).out('knows').name.submit(g.compute())
==>vadas
==>josh

The first traversal assumes the standard `Traversal` iterator should be `next'd()` for its results. The second traversal is submitted to `g.compute()` which is the `GraphComputer` associated with the graph `g`. GraphComputer forms the foundation of the OLAP model of TinkerPop3. GraphComputer takes a `VertexProgram`. A VertexProgram can be thought of as a piece of code that is executed at each vertex in logical parallel until some termination condition is met (e.g. a number of iterations have occurred, no more data is changing values, etc.). The GraphComputer is submitted a VertexProgram and that VertexProgram is copied to all the vertices in the graph. Then the GraphComputer orchestrates the execution of the `VertexProgram.execute()` method on all the vertices in an link:http://en.wikipedia.org/wiki/Bulk_synchronous_parallel[bulk synchronous parallel] (BSP) fashion. The vertices are then able to communicate with one another via messages. There are two types of messages in Gremlin OLAP: `LocalMessage` and `GlobalMessage`. A local message is a message to an incident edge or adjacent vertex. A global message is a message to any arbitrary element in the graph. 

image::graphcomputer.png[width=500]

NOTE: This model of graph computing was made popular by Google's link:http://googleresearch.blogspot.com/2009/06/large-scale-graph-computing-at-google.html[Pregel] graph system. In the open source world, this model is found in OLAP graph computing systems such as link:https://giraph.apache.org/[Giraph], link:https://hama.apache.org/[Hama], and link:http://faunus.thinkaurelius.com[Faunus].

[source,groovy]
g.v(1).out('knows').name.submit(g.compute())
==>vadas
==>josh

In the traversal above, the traversal is put into a newly constructed `TraversalVertexProgram` and that program is sent to each vertex in the graph. There are 3 BSP iterations and each iterations is interpreted as such:

 . If my vertex has the id 1, put a counter on my vertex.
 . For every counter at my vertex, send it to those vertices adjacent to me by a knows-edge.
 . For every counter at my vertex, send it to the name-property on my vertex.

When this returns, it returns an weighted iterator where those objects with counters are iterated and displayed for the number of counters on associated with that object.

NOTE: This model of path-based graph traversal in a BSP system was made popular by the link:http://faunus.thinkaurelius.com[Faunus] graph analytics system and originally described in link:http://markorodriguez.com/2011/04/19/local-and-distributed-traversal-engines/[Local and Distributed Traversal Engines]

A Collection of VertexPrograms
------------------------------

PageRankVertexProgram
~~~~~~~~~~~~~~~~~~~~~

Perhaps the most popular OLAP-oriented graph algorithm is link:http://en.wikipedia.org/wiki/PageRank[PageRank]. This eigenvector centrality variant was developed by Brin and Page of Google.

[source,java]
----
public class PageRankVertexProgram implements VertexProgram<Double> {

    private MessageType.Local messageType = MessageType.Local.of(new VertexQueryBuilder().direction(Direction.OUT));

    private double vertexCountAsDouble = 1;
    private double alpha = 0.85d;
    private int totalIterations = 30;

    public PageRankVertexProgram() {

    }

    public void initialize(final Configuration configuration) {
        this.vertexCountAsDouble = configuration.getDouble(VERTEX_COUNT, 1.0d);
        this.alpha = configuration.getDouble(ALPHA, 0.85d);
        this.totalIterations = configuration.getInt(TOTAL_ITERATIONS, 30);
    }

    public Map<String, KeyType> getComputeKeys() {
        return VertexProgram.ofComputeKeys(PAGE_RANK, KeyType.VARIABLE, EDGE_COUNT, KeyType.CONSTANT);
    }

    public Class<Double> getMessageClass() {
        return Double.class;
    }

    public void setup(final GraphComputer.SideEffects sideEffects) {

    }

    public void execute(final Vertex vertex, Messenger<Double> messenger, final GraphComputer.SideEffects sideEffects) {
        if (sideEffects.isInitialIteration()) {
            double initialPageRank = 1.0d / this.vertexCountAsDouble;
            double edgeCount = Long.valueOf(this.messageType.getQuery().build(vertex).count()).doubleValue();
            vertex.setProperty(PAGE_RANK, initialPageRank);
            vertex.setProperty(EDGE_COUNT, edgeCount);
            messenger.sendMessage(vertex, this.messageType, initialPageRank / edgeCount);
        } else {
            double newPageRank = StreamFactory.stream(messenger.receiveMessages(vertex, this.messageType)).reduce(0.0d, (a, b) -> a + b);
            newPageRank = (this.alpha * newPageRank) + ((1.0d - this.alpha) / this.vertexCountAsDouble);
            vertex.setProperty(PAGE_RANK, newPageRank);
            messenger.sendMessage(vertex, this.messageType, newPageRank / vertex.<Double>getProperty(EDGE_COUNT).orElse(0.0d));
        }
    }

    public boolean terminate(final GraphComputer.SideEffects sideEffects) {
        return sideEffects.getIteration() >= this.totalIterations;
    }
----


Gremlin Utilities
=================

Gremlin I/O
----------

GraphML Reader/Writer
~~~~~~~~~~~~~~~~~~~~~

Kryo Reader/Writer
~~~~~~~~~~~~~~~~~~

Gremlin Server
--------------

Graph Strategy
--------------



Implementations
===============

Neo4j-Gremlin
-------------

Giraph-Gremlin
--------------
